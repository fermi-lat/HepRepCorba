// This file is generated by omniidl (C++ backend)- omniORB_4_0. Do not edit.

#include "HepRep.hh"
#include <omniORB4/tcDescriptor.h>

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_0;

static CORBA::TypeCode_ptr _0RL_tc_StringArray = CORBA::TypeCode::PR_alias_tc("IDL:StringArray:1.0", "StringArray", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0)));


const CORBA::TypeCode_ptr _tc_StringArray = _0RL_tc_StringArray;

static CORBA::PR_structMember _0RL_structmember_HepRepAttDef[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0)},
  {"desc", CORBA::TypeCode::PR_string_tc(0)},
  {"category", CORBA::TypeCode::PR_string_tc(0)},
  {"extra", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_HepRepAttDef = CORBA::TypeCode::PR_struct_tc("IDL:HepRepAttDef:1.0", "HepRepAttDef", _0RL_structmember_HepRepAttDef, 4);
const CORBA::TypeCode_ptr _tc_HepRepAttDef = _0RL_tc_HepRepAttDef;






static CORBA::TypeCode_ptr _0RL_tc_HepRepAttDefList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepAttDefList:1.0", "HepRepAttDefList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepAttDef));


const CORBA::TypeCode_ptr _tc_HepRepAttDefList = _0RL_tc_HepRepAttDefList;

static CORBA::PR_structMember _0RL_structmember_HepRepAttValue[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0)},
  {"value", CORBA::TypeCode::PR_any_tc()},
  {"showLabel", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_HepRepAttValue = CORBA::TypeCode::PR_struct_tc("IDL:HepRepAttValue:1.0", "HepRepAttValue", _0RL_structmember_HepRepAttValue, 3);
const CORBA::TypeCode_ptr _tc_HepRepAttValue = _0RL_tc_HepRepAttValue;






static CORBA::TypeCode_ptr _0RL_tc_HepRepAttValueList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepAttValueList:1.0", "HepRepAttValueList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepAttValue));


const CORBA::TypeCode_ptr _tc_HepRepAttValueList = _0RL_tc_HepRepAttValueList;


static CORBA::PR_structMember _0RL_structmember_HepRepPoint[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"z", CORBA::TypeCode::PR_double_tc()},
  {"attValues", _0RL_tc_HepRepAttValueList}
};

static CORBA::TypeCode_ptr _0RL_tc_HepRepPoint = CORBA::TypeCode::PR_struct_tc("IDL:HepRepPoint:1.0", "HepRepPoint", _0RL_structmember_HepRepPoint, 4);

const CORBA::TypeCode_ptr _tc_HepRepPoint = _0RL_tc_HepRepPoint;










static CORBA::TypeCode_ptr _0RL_tc_HepRepPointList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepPointList:1.0", "HepRepPointList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepPoint));


const CORBA::TypeCode_ptr _tc_HepRepPointList = _0RL_tc_HepRepPointList;




static CORBA::PR_structMember _0RL_structmember_HepRepInstance[] = {
  {"typeName", CORBA::TypeCode::PR_string_tc(0)},
  {"instances", CORBA::TypeCode::PR_recursive_sequence_tc(0, 1)},
  {"points", _0RL_tc_HepRepPointList},
  {"attValues", _0RL_tc_HepRepAttValueList}
};

static CORBA::TypeCode_ptr _0RL_tc_HepRepInstance = CORBA::TypeCode::PR_struct_tc("IDL:HepRepInstance:1.0", "HepRepInstance", _0RL_structmember_HepRepInstance, 4);



const CORBA::TypeCode_ptr _tc_HepRepInstance = _0RL_tc_HepRepInstance;


















static CORBA::TypeCode_ptr _0RL_tc_HepRepInstanceList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepInstanceList:1.0", "HepRepInstanceList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepInstance));


const CORBA::TypeCode_ptr _tc_HepRepInstanceList = _0RL_tc_HepRepInstanceList;

static CORBA::PR_structMember _0RL_structmember_HepRepTreeID[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0)},
  {"version", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_HepRepTreeID = CORBA::TypeCode::PR_struct_tc("IDL:HepRepTreeID:1.0", "HepRepTreeID", _0RL_structmember_HepRepTreeID, 2);
const CORBA::TypeCode_ptr _tc_HepRepTreeID = _0RL_tc_HepRepTreeID;






static CORBA::TypeCode_ptr _0RL_tc_HepRepTreeIDList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepTreeIDList:1.0", "HepRepTreeIDList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepTreeID));


const CORBA::TypeCode_ptr _tc_HepRepTreeIDList = _0RL_tc_HepRepTreeIDList;








static CORBA::PR_structMember _0RL_structmember_HepRepInstanceTree[] = {
  {"id", _0RL_tc_HepRepTreeID},
  {"typeTreeID", _0RL_tc_HepRepTreeID},
  {"instanceTreeIDs", _0RL_tc_HepRepTreeIDList},
  {"instances", _0RL_tc_HepRepInstanceList}
};

static CORBA::TypeCode_ptr _0RL_tc_HepRepInstanceTree = CORBA::TypeCode::PR_struct_tc("IDL:HepRepInstanceTree:1.0", "HepRepInstanceTree", _0RL_structmember_HepRepInstanceTree, 4);







const CORBA::TypeCode_ptr _tc_HepRepInstanceTree = _0RL_tc_HepRepInstanceTree;




static CORBA::PR_structMember _0RL_structmember_HepRepType[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0)},
  {"desc", CORBA::TypeCode::PR_string_tc(0)},
  {"infoURL", CORBA::TypeCode::PR_string_tc(0)},
  {"types", CORBA::TypeCode::PR_recursive_sequence_tc(0, 1)},
  {"attDefs", _0RL_tc_HepRepAttDefList},
  {"attValues", _0RL_tc_HepRepAttValueList}
};

static CORBA::TypeCode_ptr _0RL_tc_HepRepType = CORBA::TypeCode::PR_struct_tc("IDL:HepRepType:1.0", "HepRepType", _0RL_structmember_HepRepType, 6);


const CORBA::TypeCode_ptr _tc_HepRepType = _0RL_tc_HepRepType;














static CORBA::TypeCode_ptr _0RL_tc_HepRepTypeList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepTypeList:1.0", "HepRepTypeList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepType));


const CORBA::TypeCode_ptr _tc_HepRepTypeList = _0RL_tc_HepRepTypeList;





static CORBA::PR_structMember _0RL_structmember_HepRepTypeTree[] = {
  {"id", _0RL_tc_HepRepTreeID},
  {"types", _0RL_tc_HepRepTypeList}
};

static CORBA::TypeCode_ptr _0RL_tc_HepRepTypeTree = CORBA::TypeCode::PR_struct_tc("IDL:HepRepTypeTree:1.0", "HepRepTypeTree", _0RL_structmember_HepRepTypeTree, 2);




const CORBA::TypeCode_ptr _tc_HepRepTypeTree = _0RL_tc_HepRepTypeTree;


static CORBA::PR_structMember _0RL_structmember_HepRepAction[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0)},
  {"expression", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_HepRepAction = CORBA::TypeCode::PR_struct_tc("IDL:HepRepAction:1.0", "HepRepAction", _0RL_structmember_HepRepAction, 2);
const CORBA::TypeCode_ptr _tc_HepRepAction = _0RL_tc_HepRepAction;






static CORBA::TypeCode_ptr _0RL_tc_HepRepActionList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepActionList:1.0", "HepRepActionList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepAction));


const CORBA::TypeCode_ptr _tc_HepRepActionList = _0RL_tc_HepRepActionList;

const CORBA::TypeCode_ptr _tc_HepRep = CORBA::TypeCode::PR_interface_tc("IDL:HepRep:1.0", "HepRep");

#ifndef __0RL_tcParser_buildDesc_s0_cstring__
#define __0RL_tcParser_buildDesc_s0_cstring__
static void
_0RL_tcParser_setElementCount_s0_cstring(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_String*)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cstring(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_String*)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cstring(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cstring(_newdesc, (*((_CORBA_Unbounded_Sequence_String*)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cstring(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_String& _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cstring;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cstring;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cstring;
  }
#endif

void operator <<= (CORBA::Any& _a, const StringArray& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cstring(tcdesc, _s);
  _a.PR_packFrom(_tc_StringArray, &tcdesc);
}

void _0RL_seq_delete_StringArray(void* _data)
{
  delete (StringArray*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, StringArray*& _s_out)
{
  return _a >>= (const StringArray*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const StringArray*& _s_out)
{
  _s_out = 0;
  StringArray* stmp = (StringArray*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new StringArray;
    _0RL_buildDesc_s0_cstring(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_StringArray, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_StringArray);
      _s_out = stmp;
      return 1;
    } else {
      delete (StringArray *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_StringArray) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_HepRepAttDef(void* _data) {
  HepRepAttDef* _0RL_t = (HepRepAttDef*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_HepRepAttDef(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepAttDef*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepAttDef*)_desc->opq_struct)->desc);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepAttDef*)_desc->opq_struct)->category);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepAttDef*)_desc->opq_struct)->extra);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_HepRepAttDef(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_cHepRepAttDef(tcDescriptor &_desc, const HepRepAttDef& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_HepRepAttDef;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_HepRepAttDef;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const HepRepAttDef& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepAttDef(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_HepRepAttDef, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, HepRepAttDef* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepAttDef(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_HepRepAttDef, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepAttDef*& _sp) {
  return _a >>= (const HepRepAttDef*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepAttDef*& _sp) {
  _sp = (HepRepAttDef *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new HepRepAttDef;
    _0RL_buildDesc_cHepRepAttDef(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_HepRepAttDef, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_HepRepAttDef);
      return 1;
    } else {
      delete (HepRepAttDef *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_HepRepAttDef)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cHepRepAttDef__
#define __0RL_tcParser_buildDesc_s0_cHepRepAttDef__
static void
_0RL_tcParser_setElementCount_s0_cHepRepAttDef(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< HepRepAttDef > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cHepRepAttDef(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< HepRepAttDef > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cHepRepAttDef(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cHepRepAttDef(_newdesc, (*((_CORBA_Unbounded_Sequence< HepRepAttDef > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cHepRepAttDef(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< HepRepAttDef > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cHepRepAttDef;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cHepRepAttDef;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cHepRepAttDef;
  }
#endif

void operator <<= (CORBA::Any& _a, const HepRepAttDefList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cHepRepAttDef(tcdesc, _s);
  _a.PR_packFrom(_tc_HepRepAttDefList, &tcdesc);
}

void _0RL_seq_delete_HepRepAttDefList(void* _data)
{
  delete (HepRepAttDefList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, HepRepAttDefList*& _s_out)
{
  return _a >>= (const HepRepAttDefList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const HepRepAttDefList*& _s_out)
{
  _s_out = 0;
  HepRepAttDefList* stmp = (HepRepAttDefList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new HepRepAttDefList;
    _0RL_buildDesc_s0_cHepRepAttDef(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_HepRepAttDefList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_HepRepAttDefList);
      _s_out = stmp;
      return 1;
    } else {
      delete (HepRepAttDefList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_HepRepAttDefList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_HepRepAttValue(void* _data) {
  HepRepAttValue* _0RL_t = (HepRepAttValue*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_HepRepAttValue(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepAttValue*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cany(_newdesc, ((HepRepAttValue*)_desc->opq_struct)->value);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((HepRepAttValue*)_desc->opq_struct)->showLabel);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_HepRepAttValue(const tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_cHepRepAttValue(tcDescriptor &_desc, const HepRepAttValue& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_HepRepAttValue;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_HepRepAttValue;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const HepRepAttValue& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepAttValue(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_HepRepAttValue, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, HepRepAttValue* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepAttValue(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_HepRepAttValue, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepAttValue*& _sp) {
  return _a >>= (const HepRepAttValue*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepAttValue*& _sp) {
  _sp = (HepRepAttValue *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new HepRepAttValue;
    _0RL_buildDesc_cHepRepAttValue(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_HepRepAttValue, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_HepRepAttValue);
      return 1;
    } else {
      delete (HepRepAttValue *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_HepRepAttValue)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cHepRepAttValue__
#define __0RL_tcParser_buildDesc_s0_cHepRepAttValue__
static void
_0RL_tcParser_setElementCount_s0_cHepRepAttValue(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< HepRepAttValue > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cHepRepAttValue(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< HepRepAttValue > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cHepRepAttValue(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cHepRepAttValue(_newdesc, (*((_CORBA_Unbounded_Sequence< HepRepAttValue > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cHepRepAttValue(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< HepRepAttValue > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cHepRepAttValue;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cHepRepAttValue;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cHepRepAttValue;
  }
#endif

void operator <<= (CORBA::Any& _a, const HepRepAttValueList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cHepRepAttValue(tcdesc, _s);
  _a.PR_packFrom(_tc_HepRepAttValueList, &tcdesc);
}

void _0RL_seq_delete_HepRepAttValueList(void* _data)
{
  delete (HepRepAttValueList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, HepRepAttValueList*& _s_out)
{
  return _a >>= (const HepRepAttValueList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const HepRepAttValueList*& _s_out)
{
  _s_out = 0;
  HepRepAttValueList* stmp = (HepRepAttValueList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new HepRepAttValueList;
    _0RL_buildDesc_s0_cHepRepAttValue(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_HepRepAttValueList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_HepRepAttValueList);
      _s_out = stmp;
      return 1;
    } else {
      delete (HepRepAttValueList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_HepRepAttValueList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_HepRepPoint(void* _data) {
  HepRepPoint* _0RL_t = (HepRepPoint*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_HepRepPoint(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cdouble(_newdesc, ((HepRepPoint*)_desc->opq_struct)->x);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((HepRepPoint*)_desc->opq_struct)->y);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((HepRepPoint*)_desc->opq_struct)->z);
    return 1;
  case 3:
    _0RL_buildDesc_s0_cHepRepAttValue(_newdesc, ((HepRepPoint*)_desc->opq_struct)->attValues);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_HepRepPoint(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_cHepRepPoint(tcDescriptor &_desc, const HepRepPoint& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_HepRepPoint;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_HepRepPoint;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const HepRepPoint& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepPoint(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_HepRepPoint, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, HepRepPoint* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepPoint(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_HepRepPoint, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepPoint*& _sp) {
  return _a >>= (const HepRepPoint*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepPoint*& _sp) {
  _sp = (HepRepPoint *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new HepRepPoint;
    _0RL_buildDesc_cHepRepPoint(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_HepRepPoint, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_HepRepPoint);
      return 1;
    } else {
      delete (HepRepPoint *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_HepRepPoint)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cHepRepPoint__
#define __0RL_tcParser_buildDesc_s0_cHepRepPoint__
static void
_0RL_tcParser_setElementCount_s0_cHepRepPoint(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< HepRepPoint > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cHepRepPoint(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< HepRepPoint > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cHepRepPoint(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cHepRepPoint(_newdesc, (*((_CORBA_Unbounded_Sequence< HepRepPoint > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cHepRepPoint(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< HepRepPoint > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cHepRepPoint;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cHepRepPoint;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cHepRepPoint;
  }
#endif

void operator <<= (CORBA::Any& _a, const HepRepPointList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cHepRepPoint(tcdesc, _s);
  _a.PR_packFrom(_tc_HepRepPointList, &tcdesc);
}

void _0RL_seq_delete_HepRepPointList(void* _data)
{
  delete (HepRepPointList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, HepRepPointList*& _s_out)
{
  return _a >>= (const HepRepPointList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const HepRepPointList*& _s_out)
{
  _s_out = 0;
  HepRepPointList* stmp = (HepRepPointList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new HepRepPointList;
    _0RL_buildDesc_s0_cHepRepPoint(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_HepRepPointList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_HepRepPointList);
      _s_out = stmp;
      return 1;
    } else {
      delete (HepRepPointList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_HepRepPointList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

// struct is recursive
void _0RL_buildDesc_cHepRepInstance(tcDescriptor &, const HepRepInstance&);

void _0RL_delete_HepRepInstance(void* _data) {
  HepRepInstance* _0RL_t = (HepRepInstance*) _data;
  delete _0RL_t;
}

#ifndef __0RL_tcParser_buildDesc_s0_cHepRepInstance__
#define __0RL_tcParser_buildDesc_s0_cHepRepInstance__
static void
_0RL_tcParser_setElementCount_s0_cHepRepInstance(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< HepRepInstance > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cHepRepInstance(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< HepRepInstance > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cHepRepInstance(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cHepRepInstance(_newdesc, (*((_CORBA_Unbounded_Sequence< HepRepInstance > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cHepRepInstance(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< HepRepInstance > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cHepRepInstance;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cHepRepInstance;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cHepRepInstance;
  }
#endif

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_HepRepInstance(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepInstance*)_desc->opq_struct)->typeName);
    return 1;
  case 1:
    _0RL_buildDesc_s0_cHepRepInstance(_newdesc, ((HepRepInstance*)_desc->opq_struct)->instances);
    return 1;
  case 2:
    _0RL_buildDesc_s0_cHepRepPoint(_newdesc, ((HepRepInstance*)_desc->opq_struct)->points);
    return 1;
  case 3:
    _0RL_buildDesc_s0_cHepRepAttValue(_newdesc, ((HepRepInstance*)_desc->opq_struct)->attValues);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_HepRepInstance(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_cHepRepInstance(tcDescriptor &_desc, const HepRepInstance& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_HepRepInstance;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_HepRepInstance;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const HepRepInstance& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepInstance(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_HepRepInstance, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, HepRepInstance* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepInstance(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_HepRepInstance, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepInstance*& _sp) {
  return _a >>= (const HepRepInstance*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepInstance*& _sp) {
  _sp = (HepRepInstance *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new HepRepInstance;
    _0RL_buildDesc_cHepRepInstance(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_HepRepInstance, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_HepRepInstance);
      return 1;
    } else {
      delete (HepRepInstance *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_HepRepInstance)) return 1;
    _sp = 0;
    return 0;
  }
}
void operator <<= (CORBA::Any& _a, const HepRepInstanceList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cHepRepInstance(tcdesc, _s);
  _a.PR_packFrom(_tc_HepRepInstanceList, &tcdesc);
}

void _0RL_seq_delete_HepRepInstanceList(void* _data)
{
  delete (HepRepInstanceList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, HepRepInstanceList*& _s_out)
{
  return _a >>= (const HepRepInstanceList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const HepRepInstanceList*& _s_out)
{
  _s_out = 0;
  HepRepInstanceList* stmp = (HepRepInstanceList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new HepRepInstanceList;
    _0RL_buildDesc_s0_cHepRepInstance(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_HepRepInstanceList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_HepRepInstanceList);
      _s_out = stmp;
      return 1;
    } else {
      delete (HepRepInstanceList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_HepRepInstanceList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_HepRepTreeID(void* _data) {
  HepRepTreeID* _0RL_t = (HepRepTreeID*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_HepRepTreeID(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepTreeID*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepTreeID*)_desc->opq_struct)->version);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_HepRepTreeID(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cHepRepTreeID(tcDescriptor &_desc, const HepRepTreeID& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_HepRepTreeID;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_HepRepTreeID;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const HepRepTreeID& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepTreeID(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_HepRepTreeID, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, HepRepTreeID* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepTreeID(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_HepRepTreeID, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepTreeID*& _sp) {
  return _a >>= (const HepRepTreeID*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepTreeID*& _sp) {
  _sp = (HepRepTreeID *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new HepRepTreeID;
    _0RL_buildDesc_cHepRepTreeID(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_HepRepTreeID, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_HepRepTreeID);
      return 1;
    } else {
      delete (HepRepTreeID *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_HepRepTreeID)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cHepRepTreeID__
#define __0RL_tcParser_buildDesc_s0_cHepRepTreeID__
static void
_0RL_tcParser_setElementCount_s0_cHepRepTreeID(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< HepRepTreeID > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cHepRepTreeID(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< HepRepTreeID > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cHepRepTreeID(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cHepRepTreeID(_newdesc, (*((_CORBA_Unbounded_Sequence< HepRepTreeID > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cHepRepTreeID(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< HepRepTreeID > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cHepRepTreeID;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cHepRepTreeID;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cHepRepTreeID;
  }
#endif

void operator <<= (CORBA::Any& _a, const HepRepTreeIDList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cHepRepTreeID(tcdesc, _s);
  _a.PR_packFrom(_tc_HepRepTreeIDList, &tcdesc);
}

void _0RL_seq_delete_HepRepTreeIDList(void* _data)
{
  delete (HepRepTreeIDList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, HepRepTreeIDList*& _s_out)
{
  return _a >>= (const HepRepTreeIDList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const HepRepTreeIDList*& _s_out)
{
  _s_out = 0;
  HepRepTreeIDList* stmp = (HepRepTreeIDList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new HepRepTreeIDList;
    _0RL_buildDesc_s0_cHepRepTreeID(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_HepRepTreeIDList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_HepRepTreeIDList);
      _s_out = stmp;
      return 1;
    } else {
      delete (HepRepTreeIDList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_HepRepTreeIDList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_HepRepInstanceTree(void* _data) {
  HepRepInstanceTree* _0RL_t = (HepRepInstanceTree*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_HepRepInstanceTree(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cHepRepTreeID(_newdesc, ((HepRepInstanceTree*)_desc->opq_struct)->id);
    return 1;
  case 1:
    _0RL_buildDesc_cHepRepTreeID(_newdesc, ((HepRepInstanceTree*)_desc->opq_struct)->typeTreeID);
    return 1;
  case 2:
    _0RL_buildDesc_s0_cHepRepTreeID(_newdesc, ((HepRepInstanceTree*)_desc->opq_struct)->instanceTreeIDs);
    return 1;
  case 3:
    _0RL_buildDesc_s0_cHepRepInstance(_newdesc, ((HepRepInstanceTree*)_desc->opq_struct)->instances);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_HepRepInstanceTree(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_cHepRepInstanceTree(tcDescriptor &_desc, const HepRepInstanceTree& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_HepRepInstanceTree;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_HepRepInstanceTree;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const HepRepInstanceTree& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepInstanceTree(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_HepRepInstanceTree, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, HepRepInstanceTree* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepInstanceTree(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_HepRepInstanceTree, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepInstanceTree*& _sp) {
  return _a >>= (const HepRepInstanceTree*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepInstanceTree*& _sp) {
  _sp = (HepRepInstanceTree *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new HepRepInstanceTree;
    _0RL_buildDesc_cHepRepInstanceTree(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_HepRepInstanceTree, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_HepRepInstanceTree);
      return 1;
    } else {
      delete (HepRepInstanceTree *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_HepRepInstanceTree)) return 1;
    _sp = 0;
    return 0;
  }
}
// struct is recursive
void _0RL_buildDesc_cHepRepType(tcDescriptor &, const HepRepType&);

void _0RL_delete_HepRepType(void* _data) {
  HepRepType* _0RL_t = (HepRepType*) _data;
  delete _0RL_t;
}

#ifndef __0RL_tcParser_buildDesc_s0_cHepRepType__
#define __0RL_tcParser_buildDesc_s0_cHepRepType__
static void
_0RL_tcParser_setElementCount_s0_cHepRepType(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< HepRepType > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cHepRepType(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< HepRepType > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cHepRepType(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cHepRepType(_newdesc, (*((_CORBA_Unbounded_Sequence< HepRepType > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cHepRepType(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< HepRepType > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cHepRepType;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cHepRepType;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cHepRepType;
  }
#endif

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_HepRepType(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepType*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepType*)_desc->opq_struct)->desc);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepType*)_desc->opq_struct)->infoURL);
    return 1;
  case 3:
    _0RL_buildDesc_s0_cHepRepType(_newdesc, ((HepRepType*)_desc->opq_struct)->types);
    return 1;
  case 4:
    _0RL_buildDesc_s0_cHepRepAttDef(_newdesc, ((HepRepType*)_desc->opq_struct)->attDefs);
    return 1;
  case 5:
    _0RL_buildDesc_s0_cHepRepAttValue(_newdesc, ((HepRepType*)_desc->opq_struct)->attValues);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_HepRepType(const tcStructDesc *_desc)
{
  return 6;
}

void _0RL_buildDesc_cHepRepType(tcDescriptor &_desc, const HepRepType& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_HepRepType;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_HepRepType;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const HepRepType& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepType(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_HepRepType, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, HepRepType* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepType(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_HepRepType, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepType*& _sp) {
  return _a >>= (const HepRepType*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepType*& _sp) {
  _sp = (HepRepType *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new HepRepType;
    _0RL_buildDesc_cHepRepType(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_HepRepType, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_HepRepType);
      return 1;
    } else {
      delete (HepRepType *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_HepRepType)) return 1;
    _sp = 0;
    return 0;
  }
}
void operator <<= (CORBA::Any& _a, const HepRepTypeList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cHepRepType(tcdesc, _s);
  _a.PR_packFrom(_tc_HepRepTypeList, &tcdesc);
}

void _0RL_seq_delete_HepRepTypeList(void* _data)
{
  delete (HepRepTypeList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, HepRepTypeList*& _s_out)
{
  return _a >>= (const HepRepTypeList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const HepRepTypeList*& _s_out)
{
  _s_out = 0;
  HepRepTypeList* stmp = (HepRepTypeList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new HepRepTypeList;
    _0RL_buildDesc_s0_cHepRepType(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_HepRepTypeList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_HepRepTypeList);
      _s_out = stmp;
      return 1;
    } else {
      delete (HepRepTypeList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_HepRepTypeList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_HepRepTypeTree(void* _data) {
  HepRepTypeTree* _0RL_t = (HepRepTypeTree*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_HepRepTypeTree(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cHepRepTreeID(_newdesc, ((HepRepTypeTree*)_desc->opq_struct)->id);
    return 1;
  case 1:
    _0RL_buildDesc_s0_cHepRepType(_newdesc, ((HepRepTypeTree*)_desc->opq_struct)->types);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_HepRepTypeTree(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cHepRepTypeTree(tcDescriptor &_desc, const HepRepTypeTree& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_HepRepTypeTree;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_HepRepTypeTree;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const HepRepTypeTree& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepTypeTree(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_HepRepTypeTree, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, HepRepTypeTree* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepTypeTree(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_HepRepTypeTree, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepTypeTree*& _sp) {
  return _a >>= (const HepRepTypeTree*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepTypeTree*& _sp) {
  _sp = (HepRepTypeTree *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new HepRepTypeTree;
    _0RL_buildDesc_cHepRepTypeTree(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_HepRepTypeTree, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_HepRepTypeTree);
      return 1;
    } else {
      delete (HepRepTypeTree *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_HepRepTypeTree)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_HepRepAction(void* _data) {
  HepRepAction* _0RL_t = (HepRepAction*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_HepRepAction(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepAction*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((HepRepAction*)_desc->opq_struct)->expression);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_HepRepAction(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cHepRepAction(tcDescriptor &_desc, const HepRepAction& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_HepRepAction;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_HepRepAction;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const HepRepAction& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepAction(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_HepRepAction, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, HepRepAction* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cHepRepAction(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_HepRepAction, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepAction*& _sp) {
  return _a >>= (const HepRepAction*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepAction*& _sp) {
  _sp = (HepRepAction *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new HepRepAction;
    _0RL_buildDesc_cHepRepAction(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_HepRepAction, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_HepRepAction);
      return 1;
    } else {
      delete (HepRepAction *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_HepRepAction)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cHepRepAction__
#define __0RL_tcParser_buildDesc_s0_cHepRepAction__
static void
_0RL_tcParser_setElementCount_s0_cHepRepAction(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< HepRepAction > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cHepRepAction(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< HepRepAction > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cHepRepAction(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cHepRepAction(_newdesc, (*((_CORBA_Unbounded_Sequence< HepRepAction > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cHepRepAction(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< HepRepAction > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cHepRepAction;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cHepRepAction;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cHepRepAction;
  }
#endif

void operator <<= (CORBA::Any& _a, const HepRepActionList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cHepRepAction(tcdesc, _s);
  _a.PR_packFrom(_tc_HepRepActionList, &tcdesc);
}

void _0RL_seq_delete_HepRepActionList(void* _data)
{
  delete (HepRepActionList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, HepRepActionList*& _s_out)
{
  return _a >>= (const HepRepActionList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const HepRepActionList*& _s_out)
{
  _s_out = 0;
  HepRepActionList* stmp = (HepRepActionList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new HepRepActionList;
    _0RL_buildDesc_s0_cHepRepAction(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_HepRepActionList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_HepRepActionList);
      _s_out = stmp;
      return 1;
    } else {
      delete (HepRepActionList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_HepRepActionList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_HepRep(const tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  HepRep_ptr _p = HepRep::_narrow(_ptr);
  HepRep_ptr* pp = (HepRep_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_HepRep(const tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((HepRep_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cHepRep(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< _objref_HepRep, HepRep_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_HepRep;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_HepRep;
}

void _0RL_delete_HepRep(void* _data) {
  CORBA::release((HepRep_ptr) _data);
}

void operator<<=(CORBA::Any& _a, HepRep_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< _objref_HepRep, HepRep_Helper>  tmp(_s,0);
  _0RL_buildDesc_cHepRep(tcd, tmp);
  _a.PR_packFrom(_tc_HepRep, &tcd);
}

void operator<<=(CORBA::Any& _a, HepRep_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = HepRep::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRep_ptr& _s) {
  HepRep_ptr sp = (HepRep_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    HepRep_var tmp;
    _0RL_buildDesc_cHepRep(tcd, tmp);
    if( _a.PR_unpackTo(_tc_HepRep, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(HepRep_ptr)tmp,_0RL_delete_HepRep);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = HepRep::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(_tc_HepRep)) {
    _s = sp; return 1;
    }
    else {
    _s = HepRep::_nil(); return 0;
    }
  }
}

