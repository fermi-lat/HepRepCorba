// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


#if !defined (_STRINGARRAY_CI_)
#define _STRINGARRAY_CI_

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class StringArray_var
// *************************************************************

ACE_INLINE
StringArray_var::StringArray_var (void)
  : ptr_ (0)
{}

ACE_INLINE
StringArray_var::StringArray_var (StringArray *p)
  : ptr_ (p)
{}

ACE_INLINE
StringArray_var::StringArray_var (const ::StringArray_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::StringArray (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
StringArray_var::~StringArray_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
StringArray_var &
StringArray_var::operator= (StringArray *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::StringArray_var &
StringArray_var::operator= (const ::StringArray_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          StringArray *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              StringArray (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              StringArray *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::StringArray *
StringArray_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::StringArray *
StringArray_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
StringArray_var::operator const ::StringArray &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
StringArray_var::operator ::StringArray &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
StringArray_var::operator ::StringArray &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
StringArray_var::operator ::StringArray *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
TAO_SeqElem_String_Manager
StringArray_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const ::StringArray &
StringArray_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::StringArray &
StringArray_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::StringArray *&
StringArray_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::StringArray *
StringArray_var::_retn (void)
{
  ::StringArray *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::StringArray *
StringArray_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class StringArray_out
// *************************************************************

ACE_INLINE
StringArray_out::StringArray_out (StringArray *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
StringArray_out::StringArray_out (StringArray_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
StringArray_out::StringArray_out (const ::StringArray_out &p)
  : ptr_ (ACE_const_cast (StringArray_out&, p).ptr_)
{}

ACE_INLINE
::StringArray_out &
StringArray_out::operator= (const ::StringArray_out &p)
{
  this->ptr_ = ACE_const_cast (StringArray_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::StringArray_out &
StringArray_out::operator= (StringArray *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
StringArray_out::operator ::StringArray *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::StringArray *&
StringArray_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::StringArray *
StringArray_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
TAO_SeqElem_String_Manager
StringArray_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be\be_structure.cpp:194

// *************************************************************
// Inline operations for class HepRepAttDef_var
// *************************************************************

ACE_INLINE
HepRepAttDef_var::HepRepAttDef_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepAttDef_var::HepRepAttDef_var (HepRepAttDef *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepAttDef_var::HepRepAttDef_var (const ::HepRepAttDef_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepAttDef (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepAttDef_var::~HepRepAttDef_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepAttDef_var &
HepRepAttDef_var::operator= (HepRepAttDef *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::HepRepAttDef_var &
HepRepAttDef_var::operator= (const ::HepRepAttDef_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepAttDef *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepAttDef (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepAttDef *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::HepRepAttDef *
HepRepAttDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::HepRepAttDef *
HepRepAttDef_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepAttDef_var::operator const ::HepRepAttDef &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepAttDef_var::operator ::HepRepAttDef &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepAttDef_var::operator ::HepRepAttDef &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepAttDef_var::operator ::HepRepAttDef *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::HepRepAttDef &
HepRepAttDef_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::HepRepAttDef &
HepRepAttDef_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::HepRepAttDef *&
HepRepAttDef_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::HepRepAttDef *
HepRepAttDef_var::_retn (void)
{
  ::HepRepAttDef *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::HepRepAttDef *
HepRepAttDef_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:523

// *************************************************************
// Inline operations for class HepRepAttDef_out
// *************************************************************

ACE_INLINE
HepRepAttDef_out::HepRepAttDef_out (::HepRepAttDef *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepAttDef_out::HepRepAttDef_out (HepRepAttDef_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepAttDef_out::HepRepAttDef_out (const ::HepRepAttDef_out &p)
  : ptr_ (ACE_const_cast (HepRepAttDef_out&, p).ptr_)
{}

ACE_INLINE
HepRepAttDef_out &
HepRepAttDef_out::operator= (const ::HepRepAttDef_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepAttDef_out&, p).ptr_;
  return *this;
}

ACE_INLINE
HepRepAttDef_out &
HepRepAttDef_out::operator= (HepRepAttDef *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
HepRepAttDef_out::operator ::HepRepAttDef *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::HepRepAttDef *&
HepRepAttDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::HepRepAttDef *
HepRepAttDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:99

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPATTDEFLIST_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPATTDEFLIST_CI_

ACE_INLINE
HepRepAttDef *
_TAO_Unbounded_Sequence_HepRepAttDefList::allocbuf (CORBA::ULong size)
{
  HepRepAttDef *retval = 0;
  ACE_NEW_RETURN (retval, HepRepAttDef[size], 0);
  return retval;
}

ACE_INLINE
void _TAO_Unbounded_Sequence_HepRepAttDefList::freebuf (HepRepAttDef *buffer)
{
  delete [] buffer;
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepAttDefList::_TAO_Unbounded_Sequence_HepRepAttDefList (void)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepAttDefList::_TAO_Unbounded_Sequence_HepRepAttDefList (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_HepRepAttDefList::allocbuf (maximum))
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepAttDefList::_TAO_Unbounded_Sequence_HepRepAttDefList (
    CORBA::ULong maximum,
    CORBA::ULong length,
    HepRepAttDef *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepAttDefList::_TAO_Unbounded_Sequence_HepRepAttDefList (
    const _TAO_Unbounded_Sequence_HepRepAttDefList &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      HepRepAttDef *tmp1 =
        _TAO_Unbounded_Sequence_HepRepAttDefList::allocbuf (this->maximum_);
      HepRepAttDef * const tmp2 =
        ACE_reinterpret_cast (HepRepAttDef * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepAttDefList &
_TAO_Unbounded_Sequence_HepRepAttDefList::operator= (
    const _TAO_Unbounded_Sequence_HepRepAttDefList &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          HepRepAttDef *tmp =
            ACE_reinterpret_cast (HepRepAttDef *, this->buffer_);
          
          _TAO_Unbounded_Sequence_HepRepAttDefList::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_HepRepAttDefList::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_HepRepAttDefList::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  HepRepAttDef *tmp1 =
    ACE_reinterpret_cast (HepRepAttDef *, this->buffer_);
  HepRepAttDef * const tmp2 =
    ACE_reinterpret_cast (HepRepAttDef * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
HepRepAttDef &
_TAO_Unbounded_Sequence_HepRepAttDefList::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  HepRepAttDef* tmp =
    ACE_reinterpret_cast (HepRepAttDef*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const HepRepAttDef &
_TAO_Unbounded_Sequence_HepRepAttDefList::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  HepRepAttDef * const tmp =
    ACE_reinterpret_cast (HepRepAttDef* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
HepRepAttDef *
_TAO_Unbounded_Sequence_HepRepAttDefList::get_buffer (CORBA::Boolean orphan)
{
  HepRepAttDef *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_HepRepAttDefList::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (HepRepAttDef*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(HepRepAttDef*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const HepRepAttDef *
_TAO_Unbounded_Sequence_HepRepAttDefList::get_buffer (void) const
{
  return ACE_reinterpret_cast (const HepRepAttDef * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
_TAO_Unbounded_Sequence_HepRepAttDefList::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepAttDef *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      HepRepAttDef *tmp =
        ACE_reinterpret_cast (HepRepAttDef*, this->buffer_);
      _TAO_Unbounded_Sequence_HepRepAttDefList::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPATTDEFLIST_CI_)
#define _HEPREPATTDEFLIST_CI_

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class HepRepAttDefList_var
// *************************************************************

ACE_INLINE
HepRepAttDefList_var::HepRepAttDefList_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepAttDefList_var::HepRepAttDefList_var (HepRepAttDefList *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepAttDefList_var::HepRepAttDefList_var (const ::HepRepAttDefList_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepAttDefList (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepAttDefList_var::~HepRepAttDefList_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepAttDefList_var &
HepRepAttDefList_var::operator= (HepRepAttDefList *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::HepRepAttDefList_var &
HepRepAttDefList_var::operator= (const ::HepRepAttDefList_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepAttDefList *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepAttDefList (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepAttDefList *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::HepRepAttDefList *
HepRepAttDefList_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::HepRepAttDefList *
HepRepAttDefList_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepAttDefList_var::operator const ::HepRepAttDefList &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepAttDefList_var::operator ::HepRepAttDefList &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepAttDefList_var::operator ::HepRepAttDefList &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepAttDefList_var::operator ::HepRepAttDefList *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
HepRepAttDef &
HepRepAttDefList_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const HepRepAttDef &
HepRepAttDefList_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const HepRepAttDef &, this->ptr_->operator[] (index));
}

ACE_INLINE
const ::HepRepAttDefList &
HepRepAttDefList_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepAttDefList &
HepRepAttDefList_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepAttDefList *&
HepRepAttDefList_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::HepRepAttDefList *
HepRepAttDefList_var::_retn (void)
{
  ::HepRepAttDefList *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::HepRepAttDefList *
HepRepAttDefList_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class HepRepAttDefList_out
// *************************************************************

ACE_INLINE
HepRepAttDefList_out::HepRepAttDefList_out (HepRepAttDefList *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepAttDefList_out::HepRepAttDefList_out (HepRepAttDefList_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepAttDefList_out::HepRepAttDefList_out (const ::HepRepAttDefList_out &p)
  : ptr_ (ACE_const_cast (HepRepAttDefList_out&, p).ptr_)
{}

ACE_INLINE
::HepRepAttDefList_out &
HepRepAttDefList_out::operator= (const ::HepRepAttDefList_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepAttDefList_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::HepRepAttDefList_out &
HepRepAttDefList_out::operator= (HepRepAttDefList *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
HepRepAttDefList_out::operator ::HepRepAttDefList *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::HepRepAttDefList *&
HepRepAttDefList_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::HepRepAttDefList *
HepRepAttDefList_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepAttDef &
HepRepAttDefList_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be\be_structure.cpp:194

// *************************************************************
// Inline operations for class HepRepAttValue_var
// *************************************************************

ACE_INLINE
HepRepAttValue_var::HepRepAttValue_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepAttValue_var::HepRepAttValue_var (HepRepAttValue *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepAttValue_var::HepRepAttValue_var (const ::HepRepAttValue_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepAttValue (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepAttValue_var::~HepRepAttValue_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepAttValue_var &
HepRepAttValue_var::operator= (HepRepAttValue *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::HepRepAttValue_var &
HepRepAttValue_var::operator= (const ::HepRepAttValue_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepAttValue *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepAttValue (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepAttValue *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::HepRepAttValue *
HepRepAttValue_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::HepRepAttValue *
HepRepAttValue_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepAttValue_var::operator const ::HepRepAttValue &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepAttValue_var::operator ::HepRepAttValue &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepAttValue_var::operator ::HepRepAttValue &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepAttValue_var::operator ::HepRepAttValue *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::HepRepAttValue &
HepRepAttValue_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::HepRepAttValue &
HepRepAttValue_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::HepRepAttValue *&
HepRepAttValue_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::HepRepAttValue *
HepRepAttValue_var::_retn (void)
{
  ::HepRepAttValue *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::HepRepAttValue *
HepRepAttValue_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:523

// *************************************************************
// Inline operations for class HepRepAttValue_out
// *************************************************************

ACE_INLINE
HepRepAttValue_out::HepRepAttValue_out (::HepRepAttValue *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepAttValue_out::HepRepAttValue_out (HepRepAttValue_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepAttValue_out::HepRepAttValue_out (const ::HepRepAttValue_out &p)
  : ptr_ (ACE_const_cast (HepRepAttValue_out&, p).ptr_)
{}

ACE_INLINE
HepRepAttValue_out &
HepRepAttValue_out::operator= (const ::HepRepAttValue_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepAttValue_out&, p).ptr_;
  return *this;
}

ACE_INLINE
HepRepAttValue_out &
HepRepAttValue_out::operator= (HepRepAttValue *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
HepRepAttValue_out::operator ::HepRepAttValue *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::HepRepAttValue *&
HepRepAttValue_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::HepRepAttValue *
HepRepAttValue_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:99

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPATTVALUELIST_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPATTVALUELIST_CI_

ACE_INLINE
HepRepAttValue *
_TAO_Unbounded_Sequence_HepRepAttValueList::allocbuf (CORBA::ULong size)
{
  HepRepAttValue *retval = 0;
  ACE_NEW_RETURN (retval, HepRepAttValue[size], 0);
  return retval;
}

ACE_INLINE
void _TAO_Unbounded_Sequence_HepRepAttValueList::freebuf (HepRepAttValue *buffer)
{
  delete [] buffer;
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepAttValueList::_TAO_Unbounded_Sequence_HepRepAttValueList (void)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepAttValueList::_TAO_Unbounded_Sequence_HepRepAttValueList (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_HepRepAttValueList::allocbuf (maximum))
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepAttValueList::_TAO_Unbounded_Sequence_HepRepAttValueList (
    CORBA::ULong maximum,
    CORBA::ULong length,
    HepRepAttValue *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepAttValueList::_TAO_Unbounded_Sequence_HepRepAttValueList (
    const _TAO_Unbounded_Sequence_HepRepAttValueList &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      HepRepAttValue *tmp1 =
        _TAO_Unbounded_Sequence_HepRepAttValueList::allocbuf (this->maximum_);
      HepRepAttValue * const tmp2 =
        ACE_reinterpret_cast (HepRepAttValue * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepAttValueList &
_TAO_Unbounded_Sequence_HepRepAttValueList::operator= (
    const _TAO_Unbounded_Sequence_HepRepAttValueList &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          HepRepAttValue *tmp =
            ACE_reinterpret_cast (HepRepAttValue *, this->buffer_);
          
          _TAO_Unbounded_Sequence_HepRepAttValueList::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_HepRepAttValueList::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_HepRepAttValueList::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  HepRepAttValue *tmp1 =
    ACE_reinterpret_cast (HepRepAttValue *, this->buffer_);
  HepRepAttValue * const tmp2 =
    ACE_reinterpret_cast (HepRepAttValue * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
HepRepAttValue &
_TAO_Unbounded_Sequence_HepRepAttValueList::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  HepRepAttValue* tmp =
    ACE_reinterpret_cast (HepRepAttValue*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const HepRepAttValue &
_TAO_Unbounded_Sequence_HepRepAttValueList::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  HepRepAttValue * const tmp =
    ACE_reinterpret_cast (HepRepAttValue* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
HepRepAttValue *
_TAO_Unbounded_Sequence_HepRepAttValueList::get_buffer (CORBA::Boolean orphan)
{
  HepRepAttValue *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_HepRepAttValueList::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (HepRepAttValue*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(HepRepAttValue*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const HepRepAttValue *
_TAO_Unbounded_Sequence_HepRepAttValueList::get_buffer (void) const
{
  return ACE_reinterpret_cast (const HepRepAttValue * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
_TAO_Unbounded_Sequence_HepRepAttValueList::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepAttValue *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      HepRepAttValue *tmp =
        ACE_reinterpret_cast (HepRepAttValue*, this->buffer_);
      _TAO_Unbounded_Sequence_HepRepAttValueList::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPATTVALUELIST_CI_)
#define _HEPREPATTVALUELIST_CI_

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class HepRepAttValueList_var
// *************************************************************

ACE_INLINE
HepRepAttValueList_var::HepRepAttValueList_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepAttValueList_var::HepRepAttValueList_var (HepRepAttValueList *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepAttValueList_var::HepRepAttValueList_var (const ::HepRepAttValueList_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepAttValueList (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepAttValueList_var::~HepRepAttValueList_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepAttValueList_var &
HepRepAttValueList_var::operator= (HepRepAttValueList *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::HepRepAttValueList_var &
HepRepAttValueList_var::operator= (const ::HepRepAttValueList_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepAttValueList *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepAttValueList (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepAttValueList *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::HepRepAttValueList *
HepRepAttValueList_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::HepRepAttValueList *
HepRepAttValueList_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepAttValueList_var::operator const ::HepRepAttValueList &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepAttValueList_var::operator ::HepRepAttValueList &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepAttValueList_var::operator ::HepRepAttValueList &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepAttValueList_var::operator ::HepRepAttValueList *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
HepRepAttValue &
HepRepAttValueList_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const HepRepAttValue &
HepRepAttValueList_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const HepRepAttValue &, this->ptr_->operator[] (index));
}

ACE_INLINE
const ::HepRepAttValueList &
HepRepAttValueList_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepAttValueList &
HepRepAttValueList_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepAttValueList *&
HepRepAttValueList_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::HepRepAttValueList *
HepRepAttValueList_var::_retn (void)
{
  ::HepRepAttValueList *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::HepRepAttValueList *
HepRepAttValueList_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class HepRepAttValueList_out
// *************************************************************

ACE_INLINE
HepRepAttValueList_out::HepRepAttValueList_out (HepRepAttValueList *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepAttValueList_out::HepRepAttValueList_out (HepRepAttValueList_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepAttValueList_out::HepRepAttValueList_out (const ::HepRepAttValueList_out &p)
  : ptr_ (ACE_const_cast (HepRepAttValueList_out&, p).ptr_)
{}

ACE_INLINE
::HepRepAttValueList_out &
HepRepAttValueList_out::operator= (const ::HepRepAttValueList_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepAttValueList_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::HepRepAttValueList_out &
HepRepAttValueList_out::operator= (HepRepAttValueList *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
HepRepAttValueList_out::operator ::HepRepAttValueList *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::HepRepAttValueList *&
HepRepAttValueList_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::HepRepAttValueList *
HepRepAttValueList_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepAttValue &
HepRepAttValueList_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be\be_structure.cpp:194

// *************************************************************
// Inline operations for class HepRepPoint_var
// *************************************************************

ACE_INLINE
HepRepPoint_var::HepRepPoint_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepPoint_var::HepRepPoint_var (HepRepPoint *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepPoint_var::HepRepPoint_var (const ::HepRepPoint_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepPoint (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepPoint_var::~HepRepPoint_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepPoint_var &
HepRepPoint_var::operator= (HepRepPoint *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::HepRepPoint_var &
HepRepPoint_var::operator= (const ::HepRepPoint_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepPoint *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepPoint (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepPoint *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::HepRepPoint *
HepRepPoint_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::HepRepPoint *
HepRepPoint_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepPoint_var::operator const ::HepRepPoint &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepPoint_var::operator ::HepRepPoint &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepPoint_var::operator ::HepRepPoint &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepPoint_var::operator ::HepRepPoint *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::HepRepPoint &
HepRepPoint_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::HepRepPoint &
HepRepPoint_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::HepRepPoint *&
HepRepPoint_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::HepRepPoint *
HepRepPoint_var::_retn (void)
{
  ::HepRepPoint *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::HepRepPoint *
HepRepPoint_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:523

// *************************************************************
// Inline operations for class HepRepPoint_out
// *************************************************************

ACE_INLINE
HepRepPoint_out::HepRepPoint_out (::HepRepPoint *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepPoint_out::HepRepPoint_out (HepRepPoint_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepPoint_out::HepRepPoint_out (const ::HepRepPoint_out &p)
  : ptr_ (ACE_const_cast (HepRepPoint_out&, p).ptr_)
{}

ACE_INLINE
HepRepPoint_out &
HepRepPoint_out::operator= (const ::HepRepPoint_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepPoint_out&, p).ptr_;
  return *this;
}

ACE_INLINE
HepRepPoint_out &
HepRepPoint_out::operator= (HepRepPoint *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
HepRepPoint_out::operator ::HepRepPoint *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::HepRepPoint *&
HepRepPoint_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::HepRepPoint *
HepRepPoint_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:99

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPPOINTLIST_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPPOINTLIST_CI_

ACE_INLINE
HepRepPoint *
_TAO_Unbounded_Sequence_HepRepPointList::allocbuf (CORBA::ULong size)
{
  HepRepPoint *retval = 0;
  ACE_NEW_RETURN (retval, HepRepPoint[size], 0);
  return retval;
}

ACE_INLINE
void _TAO_Unbounded_Sequence_HepRepPointList::freebuf (HepRepPoint *buffer)
{
  delete [] buffer;
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepPointList::_TAO_Unbounded_Sequence_HepRepPointList (void)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepPointList::_TAO_Unbounded_Sequence_HepRepPointList (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_HepRepPointList::allocbuf (maximum))
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepPointList::_TAO_Unbounded_Sequence_HepRepPointList (
    CORBA::ULong maximum,
    CORBA::ULong length,
    HepRepPoint *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepPointList::_TAO_Unbounded_Sequence_HepRepPointList (
    const _TAO_Unbounded_Sequence_HepRepPointList &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      HepRepPoint *tmp1 =
        _TAO_Unbounded_Sequence_HepRepPointList::allocbuf (this->maximum_);
      HepRepPoint * const tmp2 =
        ACE_reinterpret_cast (HepRepPoint * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepPointList &
_TAO_Unbounded_Sequence_HepRepPointList::operator= (
    const _TAO_Unbounded_Sequence_HepRepPointList &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          HepRepPoint *tmp =
            ACE_reinterpret_cast (HepRepPoint *, this->buffer_);
          
          _TAO_Unbounded_Sequence_HepRepPointList::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_HepRepPointList::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_HepRepPointList::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  HepRepPoint *tmp1 =
    ACE_reinterpret_cast (HepRepPoint *, this->buffer_);
  HepRepPoint * const tmp2 =
    ACE_reinterpret_cast (HepRepPoint * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
HepRepPoint &
_TAO_Unbounded_Sequence_HepRepPointList::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  HepRepPoint* tmp =
    ACE_reinterpret_cast (HepRepPoint*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const HepRepPoint &
_TAO_Unbounded_Sequence_HepRepPointList::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  HepRepPoint * const tmp =
    ACE_reinterpret_cast (HepRepPoint* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
HepRepPoint *
_TAO_Unbounded_Sequence_HepRepPointList::get_buffer (CORBA::Boolean orphan)
{
  HepRepPoint *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_HepRepPointList::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (HepRepPoint*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(HepRepPoint*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const HepRepPoint *
_TAO_Unbounded_Sequence_HepRepPointList::get_buffer (void) const
{
  return ACE_reinterpret_cast (const HepRepPoint * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
_TAO_Unbounded_Sequence_HepRepPointList::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepPoint *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      HepRepPoint *tmp =
        ACE_reinterpret_cast (HepRepPoint*, this->buffer_);
      _TAO_Unbounded_Sequence_HepRepPointList::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPPOINTLIST_CI_)
#define _HEPREPPOINTLIST_CI_

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class HepRepPointList_var
// *************************************************************

ACE_INLINE
HepRepPointList_var::HepRepPointList_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepPointList_var::HepRepPointList_var (HepRepPointList *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepPointList_var::HepRepPointList_var (const ::HepRepPointList_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepPointList (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepPointList_var::~HepRepPointList_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepPointList_var &
HepRepPointList_var::operator= (HepRepPointList *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::HepRepPointList_var &
HepRepPointList_var::operator= (const ::HepRepPointList_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepPointList *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepPointList (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepPointList *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::HepRepPointList *
HepRepPointList_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::HepRepPointList *
HepRepPointList_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepPointList_var::operator const ::HepRepPointList &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepPointList_var::operator ::HepRepPointList &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepPointList_var::operator ::HepRepPointList &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepPointList_var::operator ::HepRepPointList *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
HepRepPoint &
HepRepPointList_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const HepRepPoint &
HepRepPointList_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const HepRepPoint &, this->ptr_->operator[] (index));
}

ACE_INLINE
const ::HepRepPointList &
HepRepPointList_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepPointList &
HepRepPointList_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepPointList *&
HepRepPointList_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::HepRepPointList *
HepRepPointList_var::_retn (void)
{
  ::HepRepPointList *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::HepRepPointList *
HepRepPointList_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class HepRepPointList_out
// *************************************************************

ACE_INLINE
HepRepPointList_out::HepRepPointList_out (HepRepPointList *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepPointList_out::HepRepPointList_out (HepRepPointList_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepPointList_out::HepRepPointList_out (const ::HepRepPointList_out &p)
  : ptr_ (ACE_const_cast (HepRepPointList_out&, p).ptr_)
{}

ACE_INLINE
::HepRepPointList_out &
HepRepPointList_out::operator= (const ::HepRepPointList_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepPointList_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::HepRepPointList_out &
HepRepPointList_out::operator= (HepRepPointList *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
HepRepPointList_out::operator ::HepRepPointList *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::HepRepPointList *&
HepRepPointList_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::HepRepPointList *
HepRepPointList_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepPoint &
HepRepPointList_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be\be_structure.cpp:194

// *************************************************************
// Inline operations for class HepRepInstance_var
// *************************************************************

ACE_INLINE
HepRepInstance_var::HepRepInstance_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepInstance_var::HepRepInstance_var (HepRepInstance *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepInstance_var::HepRepInstance_var (const ::HepRepInstance_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepInstance (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepInstance_var::~HepRepInstance_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepInstance_var &
HepRepInstance_var::operator= (HepRepInstance *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::HepRepInstance_var &
HepRepInstance_var::operator= (const ::HepRepInstance_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepInstance *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepInstance (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepInstance *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::HepRepInstance *
HepRepInstance_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::HepRepInstance *
HepRepInstance_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepInstance_var::operator const ::HepRepInstance &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepInstance_var::operator ::HepRepInstance &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepInstance_var::operator ::HepRepInstance &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepInstance_var::operator ::HepRepInstance *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::HepRepInstance &
HepRepInstance_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::HepRepInstance &
HepRepInstance_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::HepRepInstance *&
HepRepInstance_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::HepRepInstance *
HepRepInstance_var::_retn (void)
{
  ::HepRepInstance *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::HepRepInstance *
HepRepInstance_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:523

// *************************************************************
// Inline operations for class HepRepInstance_out
// *************************************************************

ACE_INLINE
HepRepInstance_out::HepRepInstance_out (::HepRepInstance *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepInstance_out::HepRepInstance_out (HepRepInstance_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepInstance_out::HepRepInstance_out (const ::HepRepInstance_out &p)
  : ptr_ (ACE_const_cast (HepRepInstance_out&, p).ptr_)
{}

ACE_INLINE
HepRepInstance_out &
HepRepInstance_out::operator= (const ::HepRepInstance_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepInstance_out&, p).ptr_;
  return *this;
}

ACE_INLINE
HepRepInstance_out &
HepRepInstance_out::operator= (HepRepInstance *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
HepRepInstance_out::operator ::HepRepInstance *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::HepRepInstance *&
HepRepInstance_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::HepRepInstance *
HepRepInstance_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:99

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPINSTANCE__TAO_SEQ_HEPREPINSTANCE_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPINSTANCE__TAO_SEQ_HEPREPINSTANCE_CI_

ACE_INLINE
HepRepInstance *
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::allocbuf (CORBA::ULong size)
{
  HepRepInstance *retval = 0;
  ACE_NEW_RETURN (retval, HepRepInstance[size], 0);
  return retval;
}

ACE_INLINE
void HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::freebuf (HepRepInstance *buffer)
{
  delete [] buffer;
}

ACE_INLINE
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance (void)
{
}

ACE_INLINE
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::allocbuf (maximum))
{
}

ACE_INLINE
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance (
    CORBA::ULong maximum,
    CORBA::ULong length,
    HepRepInstance *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance (
    const _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      HepRepInstance *tmp1 =
        _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::allocbuf (this->maximum_);
      HepRepInstance * const tmp2 =
        ACE_reinterpret_cast (HepRepInstance * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance &
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::operator= (
    const _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          HepRepInstance *tmp =
            ACE_reinterpret_cast (HepRepInstance *, this->buffer_);
          
          _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  HepRepInstance *tmp1 =
    ACE_reinterpret_cast (HepRepInstance *, this->buffer_);
  HepRepInstance * const tmp2 =
    ACE_reinterpret_cast (HepRepInstance * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
HepRepInstance &
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  HepRepInstance* tmp =
    ACE_reinterpret_cast (HepRepInstance*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const HepRepInstance &
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  HepRepInstance * const tmp =
    ACE_reinterpret_cast (HepRepInstance* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
HepRepInstance *
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::get_buffer (CORBA::Boolean orphan)
{
  HepRepInstance *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (HepRepInstance*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(HepRepInstance*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const HepRepInstance *
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::get_buffer (void) const
{
  return ACE_reinterpret_cast (const HepRepInstance * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepInstance *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      HepRepInstance *tmp =
        ACE_reinterpret_cast (HepRepInstance*, this->buffer_);
      _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:99

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPINSTANCELIST_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPINSTANCELIST_CI_

ACE_INLINE
HepRepInstance *
_TAO_Unbounded_Sequence_HepRepInstanceList::allocbuf (CORBA::ULong size)
{
  HepRepInstance *retval = 0;
  ACE_NEW_RETURN (retval, HepRepInstance[size], 0);
  return retval;
}

ACE_INLINE
void _TAO_Unbounded_Sequence_HepRepInstanceList::freebuf (HepRepInstance *buffer)
{
  delete [] buffer;
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepInstanceList::_TAO_Unbounded_Sequence_HepRepInstanceList (void)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepInstanceList::_TAO_Unbounded_Sequence_HepRepInstanceList (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_HepRepInstanceList::allocbuf (maximum))
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepInstanceList::_TAO_Unbounded_Sequence_HepRepInstanceList (
    CORBA::ULong maximum,
    CORBA::ULong length,
    HepRepInstance *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepInstanceList::_TAO_Unbounded_Sequence_HepRepInstanceList (
    const _TAO_Unbounded_Sequence_HepRepInstanceList &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      HepRepInstance *tmp1 =
        _TAO_Unbounded_Sequence_HepRepInstanceList::allocbuf (this->maximum_);
      HepRepInstance * const tmp2 =
        ACE_reinterpret_cast (HepRepInstance * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepInstanceList &
_TAO_Unbounded_Sequence_HepRepInstanceList::operator= (
    const _TAO_Unbounded_Sequence_HepRepInstanceList &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          HepRepInstance *tmp =
            ACE_reinterpret_cast (HepRepInstance *, this->buffer_);
          
          _TAO_Unbounded_Sequence_HepRepInstanceList::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_HepRepInstanceList::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_HepRepInstanceList::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  HepRepInstance *tmp1 =
    ACE_reinterpret_cast (HepRepInstance *, this->buffer_);
  HepRepInstance * const tmp2 =
    ACE_reinterpret_cast (HepRepInstance * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
HepRepInstance &
_TAO_Unbounded_Sequence_HepRepInstanceList::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  HepRepInstance* tmp =
    ACE_reinterpret_cast (HepRepInstance*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const HepRepInstance &
_TAO_Unbounded_Sequence_HepRepInstanceList::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  HepRepInstance * const tmp =
    ACE_reinterpret_cast (HepRepInstance* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
HepRepInstance *
_TAO_Unbounded_Sequence_HepRepInstanceList::get_buffer (CORBA::Boolean orphan)
{
  HepRepInstance *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_HepRepInstanceList::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (HepRepInstance*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(HepRepInstance*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const HepRepInstance *
_TAO_Unbounded_Sequence_HepRepInstanceList::get_buffer (void) const
{
  return ACE_reinterpret_cast (const HepRepInstance * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
_TAO_Unbounded_Sequence_HepRepInstanceList::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepInstance *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      HepRepInstance *tmp =
        ACE_reinterpret_cast (HepRepInstance*, this->buffer_);
      _TAO_Unbounded_Sequence_HepRepInstanceList::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPINSTANCELIST_CI_)
#define _HEPREPINSTANCELIST_CI_

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class HepRepInstanceList_var
// *************************************************************

ACE_INLINE
HepRepInstanceList_var::HepRepInstanceList_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepInstanceList_var::HepRepInstanceList_var (HepRepInstanceList *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepInstanceList_var::HepRepInstanceList_var (const ::HepRepInstanceList_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepInstanceList (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepInstanceList_var::~HepRepInstanceList_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepInstanceList_var &
HepRepInstanceList_var::operator= (HepRepInstanceList *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::HepRepInstanceList_var &
HepRepInstanceList_var::operator= (const ::HepRepInstanceList_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepInstanceList *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepInstanceList (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepInstanceList *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::HepRepInstanceList *
HepRepInstanceList_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::HepRepInstanceList *
HepRepInstanceList_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepInstanceList_var::operator const ::HepRepInstanceList &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepInstanceList_var::operator ::HepRepInstanceList &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepInstanceList_var::operator ::HepRepInstanceList &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepInstanceList_var::operator ::HepRepInstanceList *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
HepRepInstance &
HepRepInstanceList_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const HepRepInstance &
HepRepInstanceList_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const HepRepInstance &, this->ptr_->operator[] (index));
}

ACE_INLINE
const ::HepRepInstanceList &
HepRepInstanceList_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepInstanceList &
HepRepInstanceList_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepInstanceList *&
HepRepInstanceList_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::HepRepInstanceList *
HepRepInstanceList_var::_retn (void)
{
  ::HepRepInstanceList *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::HepRepInstanceList *
HepRepInstanceList_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class HepRepInstanceList_out
// *************************************************************

ACE_INLINE
HepRepInstanceList_out::HepRepInstanceList_out (HepRepInstanceList *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepInstanceList_out::HepRepInstanceList_out (HepRepInstanceList_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepInstanceList_out::HepRepInstanceList_out (const ::HepRepInstanceList_out &p)
  : ptr_ (ACE_const_cast (HepRepInstanceList_out&, p).ptr_)
{}

ACE_INLINE
::HepRepInstanceList_out &
HepRepInstanceList_out::operator= (const ::HepRepInstanceList_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepInstanceList_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::HepRepInstanceList_out &
HepRepInstanceList_out::operator= (HepRepInstanceList *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
HepRepInstanceList_out::operator ::HepRepInstanceList *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::HepRepInstanceList *&
HepRepInstanceList_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::HepRepInstanceList *
HepRepInstanceList_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepInstance &
HepRepInstanceList_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be\be_structure.cpp:194

// *************************************************************
// Inline operations for class HepRepTreeID_var
// *************************************************************

ACE_INLINE
HepRepTreeID_var::HepRepTreeID_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepTreeID_var::HepRepTreeID_var (HepRepTreeID *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepTreeID_var::HepRepTreeID_var (const ::HepRepTreeID_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepTreeID (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepTreeID_var::~HepRepTreeID_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepTreeID_var &
HepRepTreeID_var::operator= (HepRepTreeID *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::HepRepTreeID_var &
HepRepTreeID_var::operator= (const ::HepRepTreeID_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepTreeID *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepTreeID (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepTreeID *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::HepRepTreeID *
HepRepTreeID_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::HepRepTreeID *
HepRepTreeID_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepTreeID_var::operator const ::HepRepTreeID &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepTreeID_var::operator ::HepRepTreeID &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepTreeID_var::operator ::HepRepTreeID &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepTreeID_var::operator ::HepRepTreeID *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::HepRepTreeID &
HepRepTreeID_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::HepRepTreeID &
HepRepTreeID_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::HepRepTreeID *&
HepRepTreeID_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::HepRepTreeID *
HepRepTreeID_var::_retn (void)
{
  ::HepRepTreeID *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::HepRepTreeID *
HepRepTreeID_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:523

// *************************************************************
// Inline operations for class HepRepTreeID_out
// *************************************************************

ACE_INLINE
HepRepTreeID_out::HepRepTreeID_out (::HepRepTreeID *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepTreeID_out::HepRepTreeID_out (HepRepTreeID_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepTreeID_out::HepRepTreeID_out (const ::HepRepTreeID_out &p)
  : ptr_ (ACE_const_cast (HepRepTreeID_out&, p).ptr_)
{}

ACE_INLINE
HepRepTreeID_out &
HepRepTreeID_out::operator= (const ::HepRepTreeID_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepTreeID_out&, p).ptr_;
  return *this;
}

ACE_INLINE
HepRepTreeID_out &
HepRepTreeID_out::operator= (HepRepTreeID *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
HepRepTreeID_out::operator ::HepRepTreeID *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::HepRepTreeID *&
HepRepTreeID_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::HepRepTreeID *
HepRepTreeID_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:99

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPTREEIDLIST_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPTREEIDLIST_CI_

ACE_INLINE
HepRepTreeID *
_TAO_Unbounded_Sequence_HepRepTreeIDList::allocbuf (CORBA::ULong size)
{
  HepRepTreeID *retval = 0;
  ACE_NEW_RETURN (retval, HepRepTreeID[size], 0);
  return retval;
}

ACE_INLINE
void _TAO_Unbounded_Sequence_HepRepTreeIDList::freebuf (HepRepTreeID *buffer)
{
  delete [] buffer;
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepTreeIDList::_TAO_Unbounded_Sequence_HepRepTreeIDList (void)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepTreeIDList::_TAO_Unbounded_Sequence_HepRepTreeIDList (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_HepRepTreeIDList::allocbuf (maximum))
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepTreeIDList::_TAO_Unbounded_Sequence_HepRepTreeIDList (
    CORBA::ULong maximum,
    CORBA::ULong length,
    HepRepTreeID *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepTreeIDList::_TAO_Unbounded_Sequence_HepRepTreeIDList (
    const _TAO_Unbounded_Sequence_HepRepTreeIDList &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      HepRepTreeID *tmp1 =
        _TAO_Unbounded_Sequence_HepRepTreeIDList::allocbuf (this->maximum_);
      HepRepTreeID * const tmp2 =
        ACE_reinterpret_cast (HepRepTreeID * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepTreeIDList &
_TAO_Unbounded_Sequence_HepRepTreeIDList::operator= (
    const _TAO_Unbounded_Sequence_HepRepTreeIDList &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          HepRepTreeID *tmp =
            ACE_reinterpret_cast (HepRepTreeID *, this->buffer_);
          
          _TAO_Unbounded_Sequence_HepRepTreeIDList::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_HepRepTreeIDList::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_HepRepTreeIDList::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  HepRepTreeID *tmp1 =
    ACE_reinterpret_cast (HepRepTreeID *, this->buffer_);
  HepRepTreeID * const tmp2 =
    ACE_reinterpret_cast (HepRepTreeID * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
HepRepTreeID &
_TAO_Unbounded_Sequence_HepRepTreeIDList::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  HepRepTreeID* tmp =
    ACE_reinterpret_cast (HepRepTreeID*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const HepRepTreeID &
_TAO_Unbounded_Sequence_HepRepTreeIDList::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  HepRepTreeID * const tmp =
    ACE_reinterpret_cast (HepRepTreeID* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
HepRepTreeID *
_TAO_Unbounded_Sequence_HepRepTreeIDList::get_buffer (CORBA::Boolean orphan)
{
  HepRepTreeID *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_HepRepTreeIDList::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (HepRepTreeID*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(HepRepTreeID*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const HepRepTreeID *
_TAO_Unbounded_Sequence_HepRepTreeIDList::get_buffer (void) const
{
  return ACE_reinterpret_cast (const HepRepTreeID * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
_TAO_Unbounded_Sequence_HepRepTreeIDList::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepTreeID *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      HepRepTreeID *tmp =
        ACE_reinterpret_cast (HepRepTreeID*, this->buffer_);
      _TAO_Unbounded_Sequence_HepRepTreeIDList::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPTREEIDLIST_CI_)
#define _HEPREPTREEIDLIST_CI_

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class HepRepTreeIDList_var
// *************************************************************

ACE_INLINE
HepRepTreeIDList_var::HepRepTreeIDList_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepTreeIDList_var::HepRepTreeIDList_var (HepRepTreeIDList *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepTreeIDList_var::HepRepTreeIDList_var (const ::HepRepTreeIDList_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepTreeIDList (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepTreeIDList_var::~HepRepTreeIDList_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepTreeIDList_var &
HepRepTreeIDList_var::operator= (HepRepTreeIDList *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::HepRepTreeIDList_var &
HepRepTreeIDList_var::operator= (const ::HepRepTreeIDList_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepTreeIDList *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepTreeIDList (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepTreeIDList *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::HepRepTreeIDList *
HepRepTreeIDList_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::HepRepTreeIDList *
HepRepTreeIDList_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepTreeIDList_var::operator const ::HepRepTreeIDList &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepTreeIDList_var::operator ::HepRepTreeIDList &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepTreeIDList_var::operator ::HepRepTreeIDList &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepTreeIDList_var::operator ::HepRepTreeIDList *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
HepRepTreeID &
HepRepTreeIDList_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const HepRepTreeID &
HepRepTreeIDList_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const HepRepTreeID &, this->ptr_->operator[] (index));
}

ACE_INLINE
const ::HepRepTreeIDList &
HepRepTreeIDList_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepTreeIDList &
HepRepTreeIDList_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepTreeIDList *&
HepRepTreeIDList_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::HepRepTreeIDList *
HepRepTreeIDList_var::_retn (void)
{
  ::HepRepTreeIDList *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::HepRepTreeIDList *
HepRepTreeIDList_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class HepRepTreeIDList_out
// *************************************************************

ACE_INLINE
HepRepTreeIDList_out::HepRepTreeIDList_out (HepRepTreeIDList *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepTreeIDList_out::HepRepTreeIDList_out (HepRepTreeIDList_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepTreeIDList_out::HepRepTreeIDList_out (const ::HepRepTreeIDList_out &p)
  : ptr_ (ACE_const_cast (HepRepTreeIDList_out&, p).ptr_)
{}

ACE_INLINE
::HepRepTreeIDList_out &
HepRepTreeIDList_out::operator= (const ::HepRepTreeIDList_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepTreeIDList_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::HepRepTreeIDList_out &
HepRepTreeIDList_out::operator= (HepRepTreeIDList *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
HepRepTreeIDList_out::operator ::HepRepTreeIDList *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::HepRepTreeIDList *&
HepRepTreeIDList_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::HepRepTreeIDList *
HepRepTreeIDList_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepTreeID &
HepRepTreeIDList_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be\be_structure.cpp:194

// *************************************************************
// Inline operations for class HepRepInstanceTree_var
// *************************************************************

ACE_INLINE
HepRepInstanceTree_var::HepRepInstanceTree_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepInstanceTree_var::HepRepInstanceTree_var (HepRepInstanceTree *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepInstanceTree_var::HepRepInstanceTree_var (const ::HepRepInstanceTree_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepInstanceTree (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepInstanceTree_var::~HepRepInstanceTree_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepInstanceTree_var &
HepRepInstanceTree_var::operator= (HepRepInstanceTree *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::HepRepInstanceTree_var &
HepRepInstanceTree_var::operator= (const ::HepRepInstanceTree_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepInstanceTree *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepInstanceTree (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepInstanceTree *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::HepRepInstanceTree *
HepRepInstanceTree_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::HepRepInstanceTree *
HepRepInstanceTree_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepInstanceTree_var::operator const ::HepRepInstanceTree &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepInstanceTree_var::operator ::HepRepInstanceTree &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepInstanceTree_var::operator ::HepRepInstanceTree &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepInstanceTree_var::operator ::HepRepInstanceTree *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::HepRepInstanceTree &
HepRepInstanceTree_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::HepRepInstanceTree &
HepRepInstanceTree_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::HepRepInstanceTree *&
HepRepInstanceTree_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::HepRepInstanceTree *
HepRepInstanceTree_var::_retn (void)
{
  ::HepRepInstanceTree *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::HepRepInstanceTree *
HepRepInstanceTree_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:523

// *************************************************************
// Inline operations for class HepRepInstanceTree_out
// *************************************************************

ACE_INLINE
HepRepInstanceTree_out::HepRepInstanceTree_out (::HepRepInstanceTree *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepInstanceTree_out::HepRepInstanceTree_out (HepRepInstanceTree_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepInstanceTree_out::HepRepInstanceTree_out (const ::HepRepInstanceTree_out &p)
  : ptr_ (ACE_const_cast (HepRepInstanceTree_out&, p).ptr_)
{}

ACE_INLINE
HepRepInstanceTree_out &
HepRepInstanceTree_out::operator= (const ::HepRepInstanceTree_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepInstanceTree_out&, p).ptr_;
  return *this;
}

ACE_INLINE
HepRepInstanceTree_out &
HepRepInstanceTree_out::operator= (HepRepInstanceTree *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
HepRepInstanceTree_out::operator ::HepRepInstanceTree *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::HepRepInstanceTree *&
HepRepInstanceTree_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::HepRepInstanceTree *
HepRepInstanceTree_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:194

// *************************************************************
// Inline operations for class HepRepType_var
// *************************************************************

ACE_INLINE
HepRepType_var::HepRepType_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepType_var::HepRepType_var (HepRepType *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepType_var::HepRepType_var (const ::HepRepType_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepType (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepType_var::~HepRepType_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepType_var &
HepRepType_var::operator= (HepRepType *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::HepRepType_var &
HepRepType_var::operator= (const ::HepRepType_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepType *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepType (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepType *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::HepRepType *
HepRepType_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::HepRepType *
HepRepType_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepType_var::operator const ::HepRepType &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepType_var::operator ::HepRepType &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepType_var::operator ::HepRepType &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepType_var::operator ::HepRepType *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::HepRepType &
HepRepType_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::HepRepType &
HepRepType_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::HepRepType *&
HepRepType_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::HepRepType *
HepRepType_var::_retn (void)
{
  ::HepRepType *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::HepRepType *
HepRepType_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:523

// *************************************************************
// Inline operations for class HepRepType_out
// *************************************************************

ACE_INLINE
HepRepType_out::HepRepType_out (::HepRepType *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepType_out::HepRepType_out (HepRepType_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepType_out::HepRepType_out (const ::HepRepType_out &p)
  : ptr_ (ACE_const_cast (HepRepType_out&, p).ptr_)
{}

ACE_INLINE
HepRepType_out &
HepRepType_out::operator= (const ::HepRepType_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepType_out&, p).ptr_;
  return *this;
}

ACE_INLINE
HepRepType_out &
HepRepType_out::operator= (HepRepType *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
HepRepType_out::operator ::HepRepType *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::HepRepType *&
HepRepType_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::HepRepType *
HepRepType_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:99

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPTYPE__TAO_SEQ_HEPREPTYPE_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPTYPE__TAO_SEQ_HEPREPTYPE_CI_

ACE_INLINE
HepRepType *
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::allocbuf (CORBA::ULong size)
{
  HepRepType *retval = 0;
  ACE_NEW_RETURN (retval, HepRepType[size], 0);
  return retval;
}

ACE_INLINE
void HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::freebuf (HepRepType *buffer)
{
  delete [] buffer;
}

ACE_INLINE
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType (void)
{
}

ACE_INLINE
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::allocbuf (maximum))
{
}

ACE_INLINE
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType (
    CORBA::ULong maximum,
    CORBA::ULong length,
    HepRepType *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType (
    const _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      HepRepType *tmp1 =
        _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::allocbuf (this->maximum_);
      HepRepType * const tmp2 =
        ACE_reinterpret_cast (HepRepType * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType &
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::operator= (
    const _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          HepRepType *tmp =
            ACE_reinterpret_cast (HepRepType *, this->buffer_);
          
          _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  HepRepType *tmp1 =
    ACE_reinterpret_cast (HepRepType *, this->buffer_);
  HepRepType * const tmp2 =
    ACE_reinterpret_cast (HepRepType * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
HepRepType &
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  HepRepType* tmp =
    ACE_reinterpret_cast (HepRepType*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const HepRepType &
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  HepRepType * const tmp =
    ACE_reinterpret_cast (HepRepType* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
HepRepType *
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::get_buffer (CORBA::Boolean orphan)
{
  HepRepType *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (HepRepType*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(HepRepType*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const HepRepType *
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::get_buffer (void) const
{
  return ACE_reinterpret_cast (const HepRepType * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepType *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      HepRepType *tmp =
        ACE_reinterpret_cast (HepRepType*, this->buffer_);
      _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:99

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPTYPELIST_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPTYPELIST_CI_

ACE_INLINE
HepRepType *
_TAO_Unbounded_Sequence_HepRepTypeList::allocbuf (CORBA::ULong size)
{
  HepRepType *retval = 0;
  ACE_NEW_RETURN (retval, HepRepType[size], 0);
  return retval;
}

ACE_INLINE
void _TAO_Unbounded_Sequence_HepRepTypeList::freebuf (HepRepType *buffer)
{
  delete [] buffer;
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepTypeList::_TAO_Unbounded_Sequence_HepRepTypeList (void)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepTypeList::_TAO_Unbounded_Sequence_HepRepTypeList (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_HepRepTypeList::allocbuf (maximum))
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepTypeList::_TAO_Unbounded_Sequence_HepRepTypeList (
    CORBA::ULong maximum,
    CORBA::ULong length,
    HepRepType *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepTypeList::_TAO_Unbounded_Sequence_HepRepTypeList (
    const _TAO_Unbounded_Sequence_HepRepTypeList &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      HepRepType *tmp1 =
        _TAO_Unbounded_Sequence_HepRepTypeList::allocbuf (this->maximum_);
      HepRepType * const tmp2 =
        ACE_reinterpret_cast (HepRepType * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepTypeList &
_TAO_Unbounded_Sequence_HepRepTypeList::operator= (
    const _TAO_Unbounded_Sequence_HepRepTypeList &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          HepRepType *tmp =
            ACE_reinterpret_cast (HepRepType *, this->buffer_);
          
          _TAO_Unbounded_Sequence_HepRepTypeList::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_HepRepTypeList::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_HepRepTypeList::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  HepRepType *tmp1 =
    ACE_reinterpret_cast (HepRepType *, this->buffer_);
  HepRepType * const tmp2 =
    ACE_reinterpret_cast (HepRepType * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
HepRepType &
_TAO_Unbounded_Sequence_HepRepTypeList::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  HepRepType* tmp =
    ACE_reinterpret_cast (HepRepType*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const HepRepType &
_TAO_Unbounded_Sequence_HepRepTypeList::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  HepRepType * const tmp =
    ACE_reinterpret_cast (HepRepType* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
HepRepType *
_TAO_Unbounded_Sequence_HepRepTypeList::get_buffer (CORBA::Boolean orphan)
{
  HepRepType *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_HepRepTypeList::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (HepRepType*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(HepRepType*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const HepRepType *
_TAO_Unbounded_Sequence_HepRepTypeList::get_buffer (void) const
{
  return ACE_reinterpret_cast (const HepRepType * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
_TAO_Unbounded_Sequence_HepRepTypeList::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepType *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      HepRepType *tmp =
        ACE_reinterpret_cast (HepRepType*, this->buffer_);
      _TAO_Unbounded_Sequence_HepRepTypeList::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPTYPELIST_CI_)
#define _HEPREPTYPELIST_CI_

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class HepRepTypeList_var
// *************************************************************

ACE_INLINE
HepRepTypeList_var::HepRepTypeList_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepTypeList_var::HepRepTypeList_var (HepRepTypeList *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepTypeList_var::HepRepTypeList_var (const ::HepRepTypeList_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepTypeList (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepTypeList_var::~HepRepTypeList_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepTypeList_var &
HepRepTypeList_var::operator= (HepRepTypeList *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::HepRepTypeList_var &
HepRepTypeList_var::operator= (const ::HepRepTypeList_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepTypeList *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepTypeList (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepTypeList *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::HepRepTypeList *
HepRepTypeList_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::HepRepTypeList *
HepRepTypeList_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepTypeList_var::operator const ::HepRepTypeList &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepTypeList_var::operator ::HepRepTypeList &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepTypeList_var::operator ::HepRepTypeList &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepTypeList_var::operator ::HepRepTypeList *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
HepRepType &
HepRepTypeList_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const HepRepType &
HepRepTypeList_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const HepRepType &, this->ptr_->operator[] (index));
}

ACE_INLINE
const ::HepRepTypeList &
HepRepTypeList_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepTypeList &
HepRepTypeList_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepTypeList *&
HepRepTypeList_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::HepRepTypeList *
HepRepTypeList_var::_retn (void)
{
  ::HepRepTypeList *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::HepRepTypeList *
HepRepTypeList_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class HepRepTypeList_out
// *************************************************************

ACE_INLINE
HepRepTypeList_out::HepRepTypeList_out (HepRepTypeList *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepTypeList_out::HepRepTypeList_out (HepRepTypeList_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepTypeList_out::HepRepTypeList_out (const ::HepRepTypeList_out &p)
  : ptr_ (ACE_const_cast (HepRepTypeList_out&, p).ptr_)
{}

ACE_INLINE
::HepRepTypeList_out &
HepRepTypeList_out::operator= (const ::HepRepTypeList_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepTypeList_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::HepRepTypeList_out &
HepRepTypeList_out::operator= (HepRepTypeList *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
HepRepTypeList_out::operator ::HepRepTypeList *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::HepRepTypeList *&
HepRepTypeList_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::HepRepTypeList *
HepRepTypeList_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepType &
HepRepTypeList_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be\be_structure.cpp:194

// *************************************************************
// Inline operations for class HepRepTypeTree_var
// *************************************************************

ACE_INLINE
HepRepTypeTree_var::HepRepTypeTree_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepTypeTree_var::HepRepTypeTree_var (HepRepTypeTree *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepTypeTree_var::HepRepTypeTree_var (const ::HepRepTypeTree_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepTypeTree (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepTypeTree_var::~HepRepTypeTree_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepTypeTree_var &
HepRepTypeTree_var::operator= (HepRepTypeTree *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::HepRepTypeTree_var &
HepRepTypeTree_var::operator= (const ::HepRepTypeTree_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepTypeTree *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepTypeTree (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepTypeTree *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::HepRepTypeTree *
HepRepTypeTree_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::HepRepTypeTree *
HepRepTypeTree_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepTypeTree_var::operator const ::HepRepTypeTree &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepTypeTree_var::operator ::HepRepTypeTree &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepTypeTree_var::operator ::HepRepTypeTree &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepTypeTree_var::operator ::HepRepTypeTree *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::HepRepTypeTree &
HepRepTypeTree_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::HepRepTypeTree &
HepRepTypeTree_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::HepRepTypeTree *&
HepRepTypeTree_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::HepRepTypeTree *
HepRepTypeTree_var::_retn (void)
{
  ::HepRepTypeTree *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::HepRepTypeTree *
HepRepTypeTree_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:523

// *************************************************************
// Inline operations for class HepRepTypeTree_out
// *************************************************************

ACE_INLINE
HepRepTypeTree_out::HepRepTypeTree_out (::HepRepTypeTree *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepTypeTree_out::HepRepTypeTree_out (HepRepTypeTree_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepTypeTree_out::HepRepTypeTree_out (const ::HepRepTypeTree_out &p)
  : ptr_ (ACE_const_cast (HepRepTypeTree_out&, p).ptr_)
{}

ACE_INLINE
HepRepTypeTree_out &
HepRepTypeTree_out::operator= (const ::HepRepTypeTree_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepTypeTree_out&, p).ptr_;
  return *this;
}

ACE_INLINE
HepRepTypeTree_out &
HepRepTypeTree_out::operator= (HepRepTypeTree *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
HepRepTypeTree_out::operator ::HepRepTypeTree *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::HepRepTypeTree *&
HepRepTypeTree_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::HepRepTypeTree *
HepRepTypeTree_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:194

// *************************************************************
// Inline operations for class HepRepAction_var
// *************************************************************

ACE_INLINE
HepRepAction_var::HepRepAction_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepAction_var::HepRepAction_var (HepRepAction *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepAction_var::HepRepAction_var (const ::HepRepAction_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepAction (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepAction_var::~HepRepAction_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepAction_var &
HepRepAction_var::operator= (HepRepAction *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::HepRepAction_var &
HepRepAction_var::operator= (const ::HepRepAction_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepAction *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepAction (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepAction *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::HepRepAction *
HepRepAction_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::HepRepAction *
HepRepAction_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepAction_var::operator const ::HepRepAction &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepAction_var::operator ::HepRepAction &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepAction_var::operator ::HepRepAction &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepAction_var::operator ::HepRepAction *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::HepRepAction &
HepRepAction_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::HepRepAction &
HepRepAction_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::HepRepAction *&
HepRepAction_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::HepRepAction *
HepRepAction_var::_retn (void)
{
  ::HepRepAction *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::HepRepAction *
HepRepAction_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be\be_structure.cpp:523

// *************************************************************
// Inline operations for class HepRepAction_out
// *************************************************************

ACE_INLINE
HepRepAction_out::HepRepAction_out (::HepRepAction *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepAction_out::HepRepAction_out (HepRepAction_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepAction_out::HepRepAction_out (const ::HepRepAction_out &p)
  : ptr_ (ACE_const_cast (HepRepAction_out&, p).ptr_)
{}

ACE_INLINE
HepRepAction_out &
HepRepAction_out::operator= (const ::HepRepAction_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepAction_out&, p).ptr_;
  return *this;
}

ACE_INLINE
HepRepAction_out &
HepRepAction_out::operator= (HepRepAction *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
HepRepAction_out::operator ::HepRepAction *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::HepRepAction *&
HepRepAction_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::HepRepAction *
HepRepAction_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:99

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPACTIONLIST_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPACTIONLIST_CI_

ACE_INLINE
HepRepAction *
_TAO_Unbounded_Sequence_HepRepActionList::allocbuf (CORBA::ULong size)
{
  HepRepAction *retval = 0;
  ACE_NEW_RETURN (retval, HepRepAction[size], 0);
  return retval;
}

ACE_INLINE
void _TAO_Unbounded_Sequence_HepRepActionList::freebuf (HepRepAction *buffer)
{
  delete [] buffer;
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepActionList::_TAO_Unbounded_Sequence_HepRepActionList (void)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepActionList::_TAO_Unbounded_Sequence_HepRepActionList (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_HepRepActionList::allocbuf (maximum))
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepActionList::_TAO_Unbounded_Sequence_HepRepActionList (
    CORBA::ULong maximum,
    CORBA::ULong length,
    HepRepAction *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepActionList::_TAO_Unbounded_Sequence_HepRepActionList (
    const _TAO_Unbounded_Sequence_HepRepActionList &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      HepRepAction *tmp1 =
        _TAO_Unbounded_Sequence_HepRepActionList::allocbuf (this->maximum_);
      HepRepAction * const tmp2 =
        ACE_reinterpret_cast (HepRepAction * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
_TAO_Unbounded_Sequence_HepRepActionList &
_TAO_Unbounded_Sequence_HepRepActionList::operator= (
    const _TAO_Unbounded_Sequence_HepRepActionList &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          HepRepAction *tmp =
            ACE_reinterpret_cast (HepRepAction *, this->buffer_);
          
          _TAO_Unbounded_Sequence_HepRepActionList::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_HepRepActionList::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_HepRepActionList::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  HepRepAction *tmp1 =
    ACE_reinterpret_cast (HepRepAction *, this->buffer_);
  HepRepAction * const tmp2 =
    ACE_reinterpret_cast (HepRepAction * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
HepRepAction &
_TAO_Unbounded_Sequence_HepRepActionList::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  HepRepAction* tmp =
    ACE_reinterpret_cast (HepRepAction*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const HepRepAction &
_TAO_Unbounded_Sequence_HepRepActionList::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  HepRepAction * const tmp =
    ACE_reinterpret_cast (HepRepAction* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
HepRepAction *
_TAO_Unbounded_Sequence_HepRepActionList::get_buffer (CORBA::Boolean orphan)
{
  HepRepAction *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_HepRepActionList::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (HepRepAction*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(HepRepAction*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const HepRepAction *
_TAO_Unbounded_Sequence_HepRepActionList::get_buffer (void) const
{
  return ACE_reinterpret_cast (const HepRepAction * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
_TAO_Unbounded_Sequence_HepRepActionList::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepAction *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      HepRepAction *tmp =
        ACE_reinterpret_cast (HepRepAction*, this->buffer_);
      _TAO_Unbounded_Sequence_HepRepActionList::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPACTIONLIST_CI_)
#define _HEPREPACTIONLIST_CI_

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class HepRepActionList_var
// *************************************************************

ACE_INLINE
HepRepActionList_var::HepRepActionList_var (void)
  : ptr_ (0)
{}

ACE_INLINE
HepRepActionList_var::HepRepActionList_var (HepRepActionList *p)
  : ptr_ (p)
{}

ACE_INLINE
HepRepActionList_var::HepRepActionList_var (const ::HepRepActionList_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::HepRepActionList (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
HepRepActionList_var::~HepRepActionList_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
HepRepActionList_var &
HepRepActionList_var::operator= (HepRepActionList *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::HepRepActionList_var &
HepRepActionList_var::operator= (const ::HepRepActionList_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HepRepActionList *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HepRepActionList (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HepRepActionList *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::HepRepActionList *
HepRepActionList_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::HepRepActionList *
HepRepActionList_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepActionList_var::operator const ::HepRepActionList &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
HepRepActionList_var::operator ::HepRepActionList &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
HepRepActionList_var::operator ::HepRepActionList &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
HepRepActionList_var::operator ::HepRepActionList *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
HepRepAction &
HepRepActionList_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const HepRepAction &
HepRepActionList_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const HepRepAction &, this->ptr_->operator[] (index));
}

ACE_INLINE
const ::HepRepActionList &
HepRepActionList_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepActionList &
HepRepActionList_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::HepRepActionList *&
HepRepActionList_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::HepRepActionList *
HepRepActionList_var::_retn (void)
{
  ::HepRepActionList *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::HepRepActionList *
HepRepActionList_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class HepRepActionList_out
// *************************************************************

ACE_INLINE
HepRepActionList_out::HepRepActionList_out (HepRepActionList *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
HepRepActionList_out::HepRepActionList_out (HepRepActionList_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
HepRepActionList_out::HepRepActionList_out (const ::HepRepActionList_out &p)
  : ptr_ (ACE_const_cast (HepRepActionList_out&, p).ptr_)
{}

ACE_INLINE
::HepRepActionList_out &
HepRepActionList_out::operator= (const ::HepRepActionList_out &p)
{
  this->ptr_ = ACE_const_cast (HepRepActionList_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::HepRepActionList_out &
HepRepActionList_out::operator= (HepRepActionList *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
HepRepActionList_out::operator ::HepRepActionList *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::HepRepActionList *&
HepRepActionList_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::HepRepActionList *
HepRepActionList_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
HepRepAction &
HepRepActionList_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_HEPREP___CI_)
#define _HEPREP___CI_

ACE_INLINE
HepRep::HepRep (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->HepRep_setup_collocation (_tao_collocated);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_StringArray_I_
#define _TAO_CDR_OP_StringArray_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const StringArray &
  );

CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    StringArray &
  );

#endif /* _TAO_CDR_OP_StringArray_I_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ci.cpp:71

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepAttDef &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.desc.in ()) &&
    (strm << _tao_aggregate.category.in ()) &&
    (strm << _tao_aggregate.extra.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepAttDef &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.desc.out ()) &&
    (strm >> _tao_aggregate.category.out ()) &&
    (strm >> _tao_aggregate.extra.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_HepRepAttDefList_I_
#define _TAO_CDR_OP_HepRepAttDefList_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const HepRepAttDefList &
  );

CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    HepRepAttDefList &
  );

#endif /* _TAO_CDR_OP_HepRepAttDefList_I_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ci.cpp:71

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepAttValue &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.value) &&
    (strm << _tao_aggregate.showLabel)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepAttValue &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.value) &&
    (strm >> _tao_aggregate.showLabel)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_HepRepAttValueList_I_
#define _TAO_CDR_OP_HepRepAttValueList_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const HepRepAttValueList &
  );

CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    HepRepAttValueList &
  );

#endif /* _TAO_CDR_OP_HepRepAttValueList_I_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ci.cpp:71

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepPoint &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.x) &&
    (strm << _tao_aggregate.y) &&
    (strm << _tao_aggregate.z) &&
    (strm << _tao_aggregate.attValues)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepPoint &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.x) &&
    (strm >> _tao_aggregate.y) &&
    (strm >> _tao_aggregate.z) &&
    (strm >> _tao_aggregate.attValues)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_HepRepPointList_I_
#define _TAO_CDR_OP_HepRepPointList_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const HepRepPointList &
  );

CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    HepRepPointList &
  );

#endif /* _TAO_CDR_OP_HepRepPointList_I_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_HepRepInstance__tao_seq_HepRepInstance_I_
#define _TAO_CDR_OP_HepRepInstance__tao_seq_HepRepInstance_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const HepRepInstance::_tao_seq_HepRepInstance &
  );

CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    HepRepInstance::_tao_seq_HepRepInstance &
  );

#endif /* _TAO_CDR_OP_HepRepInstance__tao_seq_HepRepInstance_I_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ci.cpp:71

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepInstance &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.typeName.in ()) &&
    (strm << _tao_aggregate.instances) &&
    (strm << _tao_aggregate.points) &&
    (strm << _tao_aggregate.attValues)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepInstance &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.typeName.out ()) &&
    (strm >> _tao_aggregate.instances) &&
    (strm >> _tao_aggregate.points) &&
    (strm >> _tao_aggregate.attValues)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_HepRepInstanceList_I_
#define _TAO_CDR_OP_HepRepInstanceList_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const HepRepInstanceList &
  );

CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    HepRepInstanceList &
  );

#endif /* _TAO_CDR_OP_HepRepInstanceList_I_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ci.cpp:71

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepTreeID &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.version.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepTreeID &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.version.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_HepRepTreeIDList_I_
#define _TAO_CDR_OP_HepRepTreeIDList_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const HepRepTreeIDList &
  );

CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    HepRepTreeIDList &
  );

#endif /* _TAO_CDR_OP_HepRepTreeIDList_I_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ci.cpp:71

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepInstanceTree &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.id) &&
    (strm << _tao_aggregate.typeTreeID) &&
    (strm << _tao_aggregate.instanceTreeIDs) &&
    (strm << _tao_aggregate.instances)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepInstanceTree &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.id) &&
    (strm >> _tao_aggregate.typeTreeID) &&
    (strm >> _tao_aggregate.instanceTreeIDs) &&
    (strm >> _tao_aggregate.instances)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_HepRepType__tao_seq_HepRepType_I_
#define _TAO_CDR_OP_HepRepType__tao_seq_HepRepType_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const HepRepType::_tao_seq_HepRepType &
  );

CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    HepRepType::_tao_seq_HepRepType &
  );

#endif /* _TAO_CDR_OP_HepRepType__tao_seq_HepRepType_I_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ci.cpp:71

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepType &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.desc.in ()) &&
    (strm << _tao_aggregate.infoURL.in ()) &&
    (strm << _tao_aggregate.types) &&
    (strm << _tao_aggregate.attDefs) &&
    (strm << _tao_aggregate.attValues)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepType &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.desc.out ()) &&
    (strm >> _tao_aggregate.infoURL.out ()) &&
    (strm >> _tao_aggregate.types) &&
    (strm >> _tao_aggregate.attDefs) &&
    (strm >> _tao_aggregate.attValues)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_HepRepTypeList_I_
#define _TAO_CDR_OP_HepRepTypeList_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const HepRepTypeList &
  );

CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    HepRepTypeList &
  );

#endif /* _TAO_CDR_OP_HepRepTypeList_I_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ci.cpp:71

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepTypeTree &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.id) &&
    (strm << _tao_aggregate.types)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepTypeTree &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.id) &&
    (strm >> _tao_aggregate.types)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ci.cpp:71

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepAction &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.expression.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepAction &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.expression.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_HepRepActionList_I_
#define _TAO_CDR_OP_HepRepActionList_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const HepRepActionList &
  );

CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    HepRepActionList &
  );

#endif /* _TAO_CDR_OP_HepRepActionList_I_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const HepRep_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    HepRep_ptr &
  );

