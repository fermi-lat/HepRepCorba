// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "HepRep.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::TypeCode_ptr _0RL_tc_StringArray = CORBA::TypeCode::PR_alias_tc("IDL:StringArray:1.0", "StringArray", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr _tc_StringArray = _0RL_tc_StringArray;

static CORBA::PR_structMember _0RL_structmember_HepRepAttDef[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"desc", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"category", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"extra", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_HepRepAttDef
#  undef _0RL_tc_HepRepAttDef
#endif
static CORBA::TypeCode_ptr _0RL_tc_HepRepAttDef = CORBA::TypeCode::PR_struct_tc("IDL:HepRepAttDef:1.0", "HepRepAttDef", _0RL_structmember_HepRepAttDef, 4, &_0RL_tcTrack);

const CORBA::TypeCode_ptr _tc_HepRepAttDef = _0RL_tc_HepRepAttDef;






static CORBA::TypeCode_ptr _0RL_tc_HepRepAttDefList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepAttDefList:1.0", "HepRepAttDefList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepAttDef, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr _tc_HepRepAttDefList = _0RL_tc_HepRepAttDefList;

static CORBA::PR_structMember _0RL_structmember_HepRepAttValue[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"value", CORBA::TypeCode::PR_any_tc()},
  {"showLabel", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_HepRepAttValue
#  undef _0RL_tc_HepRepAttValue
#endif
static CORBA::TypeCode_ptr _0RL_tc_HepRepAttValue = CORBA::TypeCode::PR_struct_tc("IDL:HepRepAttValue:1.0", "HepRepAttValue", _0RL_structmember_HepRepAttValue, 3, &_0RL_tcTrack);

const CORBA::TypeCode_ptr _tc_HepRepAttValue = _0RL_tc_HepRepAttValue;






static CORBA::TypeCode_ptr _0RL_tc_HepRepAttValueList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepAttValueList:1.0", "HepRepAttValueList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepAttValue, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr _tc_HepRepAttValueList = _0RL_tc_HepRepAttValueList;


static CORBA::PR_structMember _0RL_structmember_HepRepPoint[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"z", CORBA::TypeCode::PR_double_tc()},
  {"attValues", _0RL_tc_HepRepAttValueList}
};

#ifdef _0RL_tc_HepRepPoint
#  undef _0RL_tc_HepRepPoint
#endif
static CORBA::TypeCode_ptr _0RL_tc_HepRepPoint = CORBA::TypeCode::PR_struct_tc("IDL:HepRepPoint:1.0", "HepRepPoint", _0RL_structmember_HepRepPoint, 4, &_0RL_tcTrack);


const CORBA::TypeCode_ptr _tc_HepRepPoint = _0RL_tc_HepRepPoint;










static CORBA::TypeCode_ptr _0RL_tc_HepRepPointList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepPointList:1.0", "HepRepPointList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepPoint, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr _tc_HepRepPointList = _0RL_tc_HepRepPointList;




static CORBA::PR_structMember _0RL_structmember_HepRepInstance[] = {
  {"typeName", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"instances", CORBA::TypeCode::PR_recursive_sequence_tc(0, 1, &_0RL_tcTrack)},
  {"points", _0RL_tc_HepRepPointList},
  {"attValues", _0RL_tc_HepRepAttValueList}
};

#ifdef _0RL_tc_HepRepInstance
#  undef _0RL_tc_HepRepInstance
#endif
static CORBA::TypeCode_ptr _0RL_tc_HepRepInstance = CORBA::TypeCode::PR_struct_tc("IDL:HepRepInstance:1.0", "HepRepInstance", _0RL_structmember_HepRepInstance, 4, &_0RL_tcTrack);




const CORBA::TypeCode_ptr _tc_HepRepInstance = _0RL_tc_HepRepInstance;


















static CORBA::TypeCode_ptr _0RL_tc_HepRepInstanceList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepInstanceList:1.0", "HepRepInstanceList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepInstance, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr _tc_HepRepInstanceList = _0RL_tc_HepRepInstanceList;

static CORBA::PR_structMember _0RL_structmember_HepRepTreeID[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"version", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_HepRepTreeID
#  undef _0RL_tc_HepRepTreeID
#endif
static CORBA::TypeCode_ptr _0RL_tc_HepRepTreeID = CORBA::TypeCode::PR_struct_tc("IDL:HepRepTreeID:1.0", "HepRepTreeID", _0RL_structmember_HepRepTreeID, 2, &_0RL_tcTrack);

const CORBA::TypeCode_ptr _tc_HepRepTreeID = _0RL_tc_HepRepTreeID;






static CORBA::TypeCode_ptr _0RL_tc_HepRepTreeIDList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepTreeIDList:1.0", "HepRepTreeIDList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepTreeID, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr _tc_HepRepTreeIDList = _0RL_tc_HepRepTreeIDList;








static CORBA::PR_structMember _0RL_structmember_HepRepInstanceTree[] = {
  {"id", _0RL_tc_HepRepTreeID},
  {"typeTreeID", _0RL_tc_HepRepTreeID},
  {"instanceTreeIDs", _0RL_tc_HepRepTreeIDList},
  {"instances", _0RL_tc_HepRepInstanceList}
};

#ifdef _0RL_tc_HepRepInstanceTree
#  undef _0RL_tc_HepRepInstanceTree
#endif
static CORBA::TypeCode_ptr _0RL_tc_HepRepInstanceTree = CORBA::TypeCode::PR_struct_tc("IDL:HepRepInstanceTree:1.0", "HepRepInstanceTree", _0RL_structmember_HepRepInstanceTree, 4, &_0RL_tcTrack);








const CORBA::TypeCode_ptr _tc_HepRepInstanceTree = _0RL_tc_HepRepInstanceTree;




static CORBA::PR_structMember _0RL_structmember_HepRepType[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"desc", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"infoURL", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"types", CORBA::TypeCode::PR_recursive_sequence_tc(0, 1, &_0RL_tcTrack)},
  {"attDefs", _0RL_tc_HepRepAttDefList},
  {"attValues", _0RL_tc_HepRepAttValueList}
};

#ifdef _0RL_tc_HepRepType
#  undef _0RL_tc_HepRepType
#endif
static CORBA::TypeCode_ptr _0RL_tc_HepRepType = CORBA::TypeCode::PR_struct_tc("IDL:HepRepType:1.0", "HepRepType", _0RL_structmember_HepRepType, 6, &_0RL_tcTrack);



const CORBA::TypeCode_ptr _tc_HepRepType = _0RL_tc_HepRepType;














static CORBA::TypeCode_ptr _0RL_tc_HepRepTypeList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepTypeList:1.0", "HepRepTypeList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepType, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr _tc_HepRepTypeList = _0RL_tc_HepRepTypeList;





static CORBA::PR_structMember _0RL_structmember_HepRepTypeTree[] = {
  {"id", _0RL_tc_HepRepTreeID},
  {"types", _0RL_tc_HepRepTypeList}
};

#ifdef _0RL_tc_HepRepTypeTree
#  undef _0RL_tc_HepRepTypeTree
#endif
static CORBA::TypeCode_ptr _0RL_tc_HepRepTypeTree = CORBA::TypeCode::PR_struct_tc("IDL:HepRepTypeTree:1.0", "HepRepTypeTree", _0RL_structmember_HepRepTypeTree, 2, &_0RL_tcTrack);





const CORBA::TypeCode_ptr _tc_HepRepTypeTree = _0RL_tc_HepRepTypeTree;


static CORBA::PR_structMember _0RL_structmember_HepRepAction[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"expression", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_HepRepAction
#  undef _0RL_tc_HepRepAction
#endif
static CORBA::TypeCode_ptr _0RL_tc_HepRepAction = CORBA::TypeCode::PR_struct_tc("IDL:HepRepAction:1.0", "HepRepAction", _0RL_structmember_HepRepAction, 2, &_0RL_tcTrack);

const CORBA::TypeCode_ptr _tc_HepRepAction = _0RL_tc_HepRepAction;






static CORBA::TypeCode_ptr _0RL_tc_HepRepActionList = CORBA::TypeCode::PR_alias_tc("IDL:HepRepActionList:1.0", "HepRepActionList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_HepRepAction, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr _tc_HepRepActionList = _0RL_tc_HepRepActionList;

const CORBA::TypeCode_ptr _tc_HepRep = CORBA::TypeCode::PR_interface_tc("IDL:HepRep:1.0", "HepRep", &_0RL_tcTrack);

static void _0RL_StringArray_marshal_fn(cdrStream& _s, void* _v)
{
  StringArray* _p = (StringArray*)_v;
  *_p >>= _s;
}
static void _0RL_StringArray_unmarshal_fn(cdrStream& _s, void*& _v)
{
  StringArray* _p = new StringArray;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_StringArray_destructor_fn(void* _v)
{
  StringArray* _p = (StringArray*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const StringArray& _s)
{
  StringArray* _p = new StringArray(_s);
  _a.PR_insert(_0RL_tc_StringArray,
               _0RL_StringArray_marshal_fn,
               _0RL_StringArray_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, StringArray* _sp)
{
  _a.PR_insert(_0RL_tc_StringArray,
               _0RL_StringArray_marshal_fn,
               _0RL_StringArray_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, StringArray*& _sp)
{
  return _a >>= (const StringArray*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const StringArray*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_StringArray,
                    _0RL_StringArray_unmarshal_fn,
                    _0RL_StringArray_marshal_fn,
                    _0RL_StringArray_destructor_fn,
                    _v)) {
    _sp = (const StringArray*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepAttDef_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepAttDef* _p = (HepRepAttDef*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepAttDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepAttDef* _p = new HepRepAttDef;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepAttDef_destructor_fn(void* _v)
{
  HepRepAttDef* _p = (HepRepAttDef*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepAttDef& _s)
{
  HepRepAttDef* _p = new HepRepAttDef(_s);
  _a.PR_insert(_0RL_tc_HepRepAttDef,
               _0RL_HepRepAttDef_marshal_fn,
               _0RL_HepRepAttDef_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepAttDef* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepAttDef,
               _0RL_HepRepAttDef_marshal_fn,
               _0RL_HepRepAttDef_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepAttDef*& _sp)
{
  return _a >>= (const HepRepAttDef*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepAttDef*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepAttDef,
                    _0RL_HepRepAttDef_unmarshal_fn,
                    _0RL_HepRepAttDef_marshal_fn,
                    _0RL_HepRepAttDef_destructor_fn,
                    _v)) {
    _sp = (const HepRepAttDef*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepAttDefList_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepAttDefList* _p = (HepRepAttDefList*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepAttDefList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepAttDefList* _p = new HepRepAttDefList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepAttDefList_destructor_fn(void* _v)
{
  HepRepAttDefList* _p = (HepRepAttDefList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepAttDefList& _s)
{
  HepRepAttDefList* _p = new HepRepAttDefList(_s);
  _a.PR_insert(_0RL_tc_HepRepAttDefList,
               _0RL_HepRepAttDefList_marshal_fn,
               _0RL_HepRepAttDefList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepAttDefList* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepAttDefList,
               _0RL_HepRepAttDefList_marshal_fn,
               _0RL_HepRepAttDefList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepAttDefList*& _sp)
{
  return _a >>= (const HepRepAttDefList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepAttDefList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepAttDefList,
                    _0RL_HepRepAttDefList_unmarshal_fn,
                    _0RL_HepRepAttDefList_marshal_fn,
                    _0RL_HepRepAttDefList_destructor_fn,
                    _v)) {
    _sp = (const HepRepAttDefList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepAttValue_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepAttValue* _p = (HepRepAttValue*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepAttValue_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepAttValue* _p = new HepRepAttValue;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepAttValue_destructor_fn(void* _v)
{
  HepRepAttValue* _p = (HepRepAttValue*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepAttValue& _s)
{
  HepRepAttValue* _p = new HepRepAttValue(_s);
  _a.PR_insert(_0RL_tc_HepRepAttValue,
               _0RL_HepRepAttValue_marshal_fn,
               _0RL_HepRepAttValue_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepAttValue* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepAttValue,
               _0RL_HepRepAttValue_marshal_fn,
               _0RL_HepRepAttValue_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepAttValue*& _sp)
{
  return _a >>= (const HepRepAttValue*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepAttValue*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepAttValue,
                    _0RL_HepRepAttValue_unmarshal_fn,
                    _0RL_HepRepAttValue_marshal_fn,
                    _0RL_HepRepAttValue_destructor_fn,
                    _v)) {
    _sp = (const HepRepAttValue*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepAttValueList_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepAttValueList* _p = (HepRepAttValueList*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepAttValueList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepAttValueList* _p = new HepRepAttValueList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepAttValueList_destructor_fn(void* _v)
{
  HepRepAttValueList* _p = (HepRepAttValueList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepAttValueList& _s)
{
  HepRepAttValueList* _p = new HepRepAttValueList(_s);
  _a.PR_insert(_0RL_tc_HepRepAttValueList,
               _0RL_HepRepAttValueList_marshal_fn,
               _0RL_HepRepAttValueList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepAttValueList* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepAttValueList,
               _0RL_HepRepAttValueList_marshal_fn,
               _0RL_HepRepAttValueList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepAttValueList*& _sp)
{
  return _a >>= (const HepRepAttValueList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepAttValueList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepAttValueList,
                    _0RL_HepRepAttValueList_unmarshal_fn,
                    _0RL_HepRepAttValueList_marshal_fn,
                    _0RL_HepRepAttValueList_destructor_fn,
                    _v)) {
    _sp = (const HepRepAttValueList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepPoint_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepPoint* _p = (HepRepPoint*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepPoint_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepPoint* _p = new HepRepPoint;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepPoint_destructor_fn(void* _v)
{
  HepRepPoint* _p = (HepRepPoint*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepPoint& _s)
{
  HepRepPoint* _p = new HepRepPoint(_s);
  _a.PR_insert(_0RL_tc_HepRepPoint,
               _0RL_HepRepPoint_marshal_fn,
               _0RL_HepRepPoint_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepPoint* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepPoint,
               _0RL_HepRepPoint_marshal_fn,
               _0RL_HepRepPoint_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepPoint*& _sp)
{
  return _a >>= (const HepRepPoint*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepPoint*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepPoint,
                    _0RL_HepRepPoint_unmarshal_fn,
                    _0RL_HepRepPoint_marshal_fn,
                    _0RL_HepRepPoint_destructor_fn,
                    _v)) {
    _sp = (const HepRepPoint*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepPointList_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepPointList* _p = (HepRepPointList*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepPointList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepPointList* _p = new HepRepPointList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepPointList_destructor_fn(void* _v)
{
  HepRepPointList* _p = (HepRepPointList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepPointList& _s)
{
  HepRepPointList* _p = new HepRepPointList(_s);
  _a.PR_insert(_0RL_tc_HepRepPointList,
               _0RL_HepRepPointList_marshal_fn,
               _0RL_HepRepPointList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepPointList* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepPointList,
               _0RL_HepRepPointList_marshal_fn,
               _0RL_HepRepPointList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepPointList*& _sp)
{
  return _a >>= (const HepRepPointList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepPointList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepPointList,
                    _0RL_HepRepPointList_unmarshal_fn,
                    _0RL_HepRepPointList_marshal_fn,
                    _0RL_HepRepPointList_destructor_fn,
                    _v)) {
    _sp = (const HepRepPointList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepInstance_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepInstance* _p = (HepRepInstance*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepInstance_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepInstance* _p = new HepRepInstance;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepInstance_destructor_fn(void* _v)
{
  HepRepInstance* _p = (HepRepInstance*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepInstance& _s)
{
  HepRepInstance* _p = new HepRepInstance(_s);
  _a.PR_insert(_0RL_tc_HepRepInstance,
               _0RL_HepRepInstance_marshal_fn,
               _0RL_HepRepInstance_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepInstance* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepInstance,
               _0RL_HepRepInstance_marshal_fn,
               _0RL_HepRepInstance_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepInstance*& _sp)
{
  return _a >>= (const HepRepInstance*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepInstance*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepInstance,
                    _0RL_HepRepInstance_unmarshal_fn,
                    _0RL_HepRepInstance_marshal_fn,
                    _0RL_HepRepInstance_destructor_fn,
                    _v)) {
    _sp = (const HepRepInstance*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepInstanceList_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepInstanceList* _p = (HepRepInstanceList*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepInstanceList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepInstanceList* _p = new HepRepInstanceList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepInstanceList_destructor_fn(void* _v)
{
  HepRepInstanceList* _p = (HepRepInstanceList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepInstanceList& _s)
{
  HepRepInstanceList* _p = new HepRepInstanceList(_s);
  _a.PR_insert(_0RL_tc_HepRepInstanceList,
               _0RL_HepRepInstanceList_marshal_fn,
               _0RL_HepRepInstanceList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepInstanceList* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepInstanceList,
               _0RL_HepRepInstanceList_marshal_fn,
               _0RL_HepRepInstanceList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepInstanceList*& _sp)
{
  return _a >>= (const HepRepInstanceList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepInstanceList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepInstanceList,
                    _0RL_HepRepInstanceList_unmarshal_fn,
                    _0RL_HepRepInstanceList_marshal_fn,
                    _0RL_HepRepInstanceList_destructor_fn,
                    _v)) {
    _sp = (const HepRepInstanceList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepTreeID_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepTreeID* _p = (HepRepTreeID*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepTreeID_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepTreeID* _p = new HepRepTreeID;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepTreeID_destructor_fn(void* _v)
{
  HepRepTreeID* _p = (HepRepTreeID*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepTreeID& _s)
{
  HepRepTreeID* _p = new HepRepTreeID(_s);
  _a.PR_insert(_0RL_tc_HepRepTreeID,
               _0RL_HepRepTreeID_marshal_fn,
               _0RL_HepRepTreeID_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepTreeID* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepTreeID,
               _0RL_HepRepTreeID_marshal_fn,
               _0RL_HepRepTreeID_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepTreeID*& _sp)
{
  return _a >>= (const HepRepTreeID*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepTreeID*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepTreeID,
                    _0RL_HepRepTreeID_unmarshal_fn,
                    _0RL_HepRepTreeID_marshal_fn,
                    _0RL_HepRepTreeID_destructor_fn,
                    _v)) {
    _sp = (const HepRepTreeID*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepTreeIDList_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepTreeIDList* _p = (HepRepTreeIDList*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepTreeIDList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepTreeIDList* _p = new HepRepTreeIDList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepTreeIDList_destructor_fn(void* _v)
{
  HepRepTreeIDList* _p = (HepRepTreeIDList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepTreeIDList& _s)
{
  HepRepTreeIDList* _p = new HepRepTreeIDList(_s);
  _a.PR_insert(_0RL_tc_HepRepTreeIDList,
               _0RL_HepRepTreeIDList_marshal_fn,
               _0RL_HepRepTreeIDList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepTreeIDList* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepTreeIDList,
               _0RL_HepRepTreeIDList_marshal_fn,
               _0RL_HepRepTreeIDList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepTreeIDList*& _sp)
{
  return _a >>= (const HepRepTreeIDList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepTreeIDList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepTreeIDList,
                    _0RL_HepRepTreeIDList_unmarshal_fn,
                    _0RL_HepRepTreeIDList_marshal_fn,
                    _0RL_HepRepTreeIDList_destructor_fn,
                    _v)) {
    _sp = (const HepRepTreeIDList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepInstanceTree_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepInstanceTree* _p = (HepRepInstanceTree*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepInstanceTree_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepInstanceTree* _p = new HepRepInstanceTree;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepInstanceTree_destructor_fn(void* _v)
{
  HepRepInstanceTree* _p = (HepRepInstanceTree*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepInstanceTree& _s)
{
  HepRepInstanceTree* _p = new HepRepInstanceTree(_s);
  _a.PR_insert(_0RL_tc_HepRepInstanceTree,
               _0RL_HepRepInstanceTree_marshal_fn,
               _0RL_HepRepInstanceTree_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepInstanceTree* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepInstanceTree,
               _0RL_HepRepInstanceTree_marshal_fn,
               _0RL_HepRepInstanceTree_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepInstanceTree*& _sp)
{
  return _a >>= (const HepRepInstanceTree*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepInstanceTree*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepInstanceTree,
                    _0RL_HepRepInstanceTree_unmarshal_fn,
                    _0RL_HepRepInstanceTree_marshal_fn,
                    _0RL_HepRepInstanceTree_destructor_fn,
                    _v)) {
    _sp = (const HepRepInstanceTree*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepType_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepType* _p = (HepRepType*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepType* _p = new HepRepType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepType_destructor_fn(void* _v)
{
  HepRepType* _p = (HepRepType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepType& _s)
{
  HepRepType* _p = new HepRepType(_s);
  _a.PR_insert(_0RL_tc_HepRepType,
               _0RL_HepRepType_marshal_fn,
               _0RL_HepRepType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepType* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepType,
               _0RL_HepRepType_marshal_fn,
               _0RL_HepRepType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepType*& _sp)
{
  return _a >>= (const HepRepType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepType,
                    _0RL_HepRepType_unmarshal_fn,
                    _0RL_HepRepType_marshal_fn,
                    _0RL_HepRepType_destructor_fn,
                    _v)) {
    _sp = (const HepRepType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepTypeList_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepTypeList* _p = (HepRepTypeList*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepTypeList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepTypeList* _p = new HepRepTypeList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepTypeList_destructor_fn(void* _v)
{
  HepRepTypeList* _p = (HepRepTypeList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepTypeList& _s)
{
  HepRepTypeList* _p = new HepRepTypeList(_s);
  _a.PR_insert(_0RL_tc_HepRepTypeList,
               _0RL_HepRepTypeList_marshal_fn,
               _0RL_HepRepTypeList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepTypeList* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepTypeList,
               _0RL_HepRepTypeList_marshal_fn,
               _0RL_HepRepTypeList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepTypeList*& _sp)
{
  return _a >>= (const HepRepTypeList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepTypeList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepTypeList,
                    _0RL_HepRepTypeList_unmarshal_fn,
                    _0RL_HepRepTypeList_marshal_fn,
                    _0RL_HepRepTypeList_destructor_fn,
                    _v)) {
    _sp = (const HepRepTypeList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepTypeTree_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepTypeTree* _p = (HepRepTypeTree*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepTypeTree_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepTypeTree* _p = new HepRepTypeTree;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepTypeTree_destructor_fn(void* _v)
{
  HepRepTypeTree* _p = (HepRepTypeTree*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepTypeTree& _s)
{
  HepRepTypeTree* _p = new HepRepTypeTree(_s);
  _a.PR_insert(_0RL_tc_HepRepTypeTree,
               _0RL_HepRepTypeTree_marshal_fn,
               _0RL_HepRepTypeTree_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepTypeTree* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepTypeTree,
               _0RL_HepRepTypeTree_marshal_fn,
               _0RL_HepRepTypeTree_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepTypeTree*& _sp)
{
  return _a >>= (const HepRepTypeTree*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepTypeTree*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepTypeTree,
                    _0RL_HepRepTypeTree_unmarshal_fn,
                    _0RL_HepRepTypeTree_marshal_fn,
                    _0RL_HepRepTypeTree_destructor_fn,
                    _v)) {
    _sp = (const HepRepTypeTree*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepAction_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepAction* _p = (HepRepAction*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepAction_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepAction* _p = new HepRepAction;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepAction_destructor_fn(void* _v)
{
  HepRepAction* _p = (HepRepAction*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepAction& _s)
{
  HepRepAction* _p = new HepRepAction(_s);
  _a.PR_insert(_0RL_tc_HepRepAction,
               _0RL_HepRepAction_marshal_fn,
               _0RL_HepRepAction_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepAction* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepAction,
               _0RL_HepRepAction_marshal_fn,
               _0RL_HepRepAction_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepAction*& _sp)
{
  return _a >>= (const HepRepAction*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepAction*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepAction,
                    _0RL_HepRepAction_unmarshal_fn,
                    _0RL_HepRepAction_marshal_fn,
                    _0RL_HepRepAction_destructor_fn,
                    _v)) {
    _sp = (const HepRepAction*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRepActionList_marshal_fn(cdrStream& _s, void* _v)
{
  HepRepActionList* _p = (HepRepActionList*)_v;
  *_p >>= _s;
}
static void _0RL_HepRepActionList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  HepRepActionList* _p = new HepRepActionList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_HepRepActionList_destructor_fn(void* _v)
{
  HepRepActionList* _p = (HepRepActionList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const HepRepActionList& _s)
{
  HepRepActionList* _p = new HepRepActionList(_s);
  _a.PR_insert(_0RL_tc_HepRepActionList,
               _0RL_HepRepActionList_marshal_fn,
               _0RL_HepRepActionList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, HepRepActionList* _sp)
{
  _a.PR_insert(_0RL_tc_HepRepActionList,
               _0RL_HepRepActionList_marshal_fn,
               _0RL_HepRepActionList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRepActionList*& _sp)
{
  return _a >>= (const HepRepActionList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const HepRepActionList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_HepRepActionList,
                    _0RL_HepRepActionList_unmarshal_fn,
                    _0RL_HepRepActionList_marshal_fn,
                    _0RL_HepRepActionList_destructor_fn,
                    _v)) {
    _sp = (const HepRepActionList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_HepRep_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_HepRep_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(HepRep::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_HepRep_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, HepRep_ptr _o)
{
  HepRep_ptr _no = HepRep::_duplicate(_o);
  _a.PR_insert(_tc_HepRep,
               _0RL_HepRep_marshal_fn,
               _0RL_HepRep_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, HepRep_ptr* _op)
{
  _a.PR_insert(_tc_HepRep,
               _0RL_HepRep_marshal_fn,
               _0RL_HepRep_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = HepRep::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, HepRep_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(_tc_HepRep,
                    _0RL_HepRep_unmarshal_fn,
                    _0RL_HepRep_marshal_fn,
                    _0RL_HepRep_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (HepRep_ptr)_r->_ptrToObjRef(HepRep::_PD_repoId);
    else
      _o = HepRep::_nil();
    return 1;
  }
  return 0;
}

