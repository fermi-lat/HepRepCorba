// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// be\be_codegen.cpp:314


#include "HepRepC.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */


#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "HepRepC.i"
#endif /* !defined INLINE */

#if !defined (_STRINGARRAY_CS_)
#define _STRINGARRAY_CS_

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// StringArray
// *************************************************************

StringArray::StringArray (void)
{}

StringArray::StringArray (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

StringArray::StringArray (
    CORBA::ULong max,
    CORBA::ULong length,
    char * *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

StringArray::StringArray (const StringArray &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

StringArray::~StringArray (void) // dtor
{}

void StringArray::_tao_any_destructor (void *_tao_void_pointer)
{
  StringArray *tmp = ACE_static_cast (StringArray*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_StringArray[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  20,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x53747269), 
  ACE_NTOHL (0x6e674172), 
  ACE_NTOHL (0x7261793a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:StringArray:1.0
  12,
  ACE_NTOHL (0x53747269), 
  ACE_NTOHL (0x6e674172), 
  ACE_NTOHL (0x72617900),  // name = StringArray
  CORBA::tk_sequence, // typecode kind
  16, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_string, 
    0U, // string length
    0U,

};

static CORBA::TypeCode _tc_TAO_tc_StringArray (
    CORBA::tk_alias,
    sizeof (_oc_StringArray),
    (char *) &_oc_StringArray,
    0,
    sizeof (StringArray)
  );

::CORBA::TypeCode_ptr _tc_StringArray =
  &_tc_TAO_tc_StringArray;

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepAttDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  21,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704174), 
  ACE_NTOHL (0x74446566), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAttDef:1.0
  13,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704174), 
  ACE_NTOHL (0x74446566), 
  ACE_NTOHL (0x0),  // name = HepRepAttDef
  4, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_string, 
  0U, // string length
  5,
  ACE_NTOHL (0x64657363), 
  ACE_NTOHL (0x0),  // name = desc
  CORBA::tk_string, 
  0U, // string length
  9,
  ACE_NTOHL (0x63617465), 
  ACE_NTOHL (0x676f7279), 
  ACE_NTOHL (0x0),  // name = category
  CORBA::tk_string, 
  0U, // string length
  6,
  ACE_NTOHL (0x65787472), 
  ACE_NTOHL (0x61000000),  // name = extra
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_HepRepAttDef (
    CORBA::tk_struct,
    sizeof (_oc_HepRepAttDef),
    (char *) &_oc_HepRepAttDef,
    0,
    sizeof (HepRepAttDef)
  );

::CORBA::TypeCode_ptr _tc_HepRepAttDef =
  &_tc_TAO_tc_HepRepAttDef;

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:67

void HepRepAttDef::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepAttDef *tmp = ACE_static_cast (HepRepAttDef*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPATTDEFLIST_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPATTDEFLIST_CS_

void
_TAO_Unbounded_Sequence_HepRepAttDefList::_allocate_buffer (CORBA::ULong length)
{
  HepRepAttDef* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_HepRepAttDefList::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      HepRepAttDef *old =
        ACE_reinterpret_cast (HepRepAttDef *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_HepRepAttDefList::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_HepRepAttDefList::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  HepRepAttDef *tmp =
    ACE_reinterpret_cast (HepRepAttDef *, this->buffer_);
  _TAO_Unbounded_Sequence_HepRepAttDefList::freebuf (tmp);
  this->buffer_ = 0;
} 

_TAO_Unbounded_Sequence_HepRepAttDefList::~_TAO_Unbounded_Sequence_HepRepAttDefList (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPATTDEFLIST_CS_)
#define _HEPREPATTDEFLIST_CS_

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// HepRepAttDefList
// *************************************************************

HepRepAttDefList::HepRepAttDefList (void)
{}

HepRepAttDefList::HepRepAttDefList (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepAttDefList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepAttDef>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

HepRepAttDefList::HepRepAttDefList (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepAttDef *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepAttDefList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepAttDef>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

HepRepAttDefList::HepRepAttDefList (const HepRepAttDefList &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepAttDefList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepAttDef>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

HepRepAttDefList::~HepRepAttDefList (void) // dtor
{}

void HepRepAttDefList::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepAttDefList *tmp = ACE_static_cast (HepRepAttDefList*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepAttDefList[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  25,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704174), 
  ACE_NTOHL (0x74446566), 
  ACE_NTOHL (0x4c697374), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAttDefList:1.0
  17,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704174), 
  ACE_NTOHL (0x74446566), 
  ACE_NTOHL (0x4c697374), 
  ACE_NTOHL (0x0),  // name = HepRepAttDefList
  CORBA::tk_sequence, // typecode kind
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    140, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      21,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x65704174), 
      ACE_NTOHL (0x74446566), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAttDef:1.0
      13,
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x65704174), 
      ACE_NTOHL (0x74446566), 
      ACE_NTOHL (0x0),  // name = HepRepAttDef
      4, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_string, 
      0U, // string length
      5,
      ACE_NTOHL (0x64657363), 
      ACE_NTOHL (0x0),  // name = desc
      CORBA::tk_string, 
      0U, // string length
      9,
      ACE_NTOHL (0x63617465), 
      ACE_NTOHL (0x676f7279), 
      ACE_NTOHL (0x0),  // name = category
      CORBA::tk_string, 
      0U, // string length
      6,
      ACE_NTOHL (0x65787472), 
      ACE_NTOHL (0x61000000),  // name = extra
      CORBA::tk_string, 
      0U, // string length

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_HepRepAttDefList (
    CORBA::tk_alias,
    sizeof (_oc_HepRepAttDefList),
    (char *) &_oc_HepRepAttDefList,
    0,
    sizeof (HepRepAttDefList)
  );

::CORBA::TypeCode_ptr _tc_HepRepAttDefList =
  &_tc_TAO_tc_HepRepAttDefList;

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepAttValue[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  23,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704174), 
  ACE_NTOHL (0x7456616c), 
  ACE_NTOHL (0x75653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValue:1.0
  15,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704174), 
  ACE_NTOHL (0x7456616c), 
  ACE_NTOHL (0x75650000),  // name = HepRepAttValue
  3, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_string, 
  0U, // string length
  6,
  ACE_NTOHL (0x76616c75), 
  ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

  10,
  ACE_NTOHL (0x73686f77), 
  ACE_NTOHL (0x4c616265), 
  ACE_NTOHL (0x6c000000),  // name = showLabel
  CORBA::tk_long,

};

static CORBA::TypeCode _tc_TAO_tc_HepRepAttValue (
    CORBA::tk_struct,
    sizeof (_oc_HepRepAttValue),
    (char *) &_oc_HepRepAttValue,
    0,
    sizeof (HepRepAttValue)
  );

::CORBA::TypeCode_ptr _tc_HepRepAttValue =
  &_tc_TAO_tc_HepRepAttValue;

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:67

void HepRepAttValue::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepAttValue *tmp = ACE_static_cast (HepRepAttValue*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPATTVALUELIST_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPATTVALUELIST_CS_

void
_TAO_Unbounded_Sequence_HepRepAttValueList::_allocate_buffer (CORBA::ULong length)
{
  HepRepAttValue* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_HepRepAttValueList::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      HepRepAttValue *old =
        ACE_reinterpret_cast (HepRepAttValue *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_HepRepAttValueList::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_HepRepAttValueList::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  HepRepAttValue *tmp =
    ACE_reinterpret_cast (HepRepAttValue *, this->buffer_);
  _TAO_Unbounded_Sequence_HepRepAttValueList::freebuf (tmp);
  this->buffer_ = 0;
} 

_TAO_Unbounded_Sequence_HepRepAttValueList::~_TAO_Unbounded_Sequence_HepRepAttValueList (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPATTVALUELIST_CS_)
#define _HEPREPATTVALUELIST_CS_

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// HepRepAttValueList
// *************************************************************

HepRepAttValueList::HepRepAttValueList (void)
{}

HepRepAttValueList::HepRepAttValueList (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepAttValueList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepAttValue>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

HepRepAttValueList::HepRepAttValueList (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepAttValue *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepAttValueList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepAttValue>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

HepRepAttValueList::HepRepAttValueList (const HepRepAttValueList &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepAttValueList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepAttValue>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

HepRepAttValueList::~HepRepAttValueList (void) // dtor
{}

void HepRepAttValueList::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepAttValueList *tmp = ACE_static_cast (HepRepAttValueList*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepAttValueList[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704174), 
  ACE_NTOHL (0x7456616c), 
  ACE_NTOHL (0x75654c69), 
  ACE_NTOHL (0x73743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValueList:1.0
  19,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704174), 
  ACE_NTOHL (0x7456616c), 
  ACE_NTOHL (0x75654c69), 
  ACE_NTOHL (0x73740000),  // name = HepRepAttValueList
  CORBA::tk_sequence, // typecode kind
  128, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    112, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      23,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x65704174), 
      ACE_NTOHL (0x7456616c), 
      ACE_NTOHL (0x75653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValue:1.0
      15,
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x65704174), 
      ACE_NTOHL (0x7456616c), 
      ACE_NTOHL (0x75650000),  // name = HepRepAttValue
      3, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_string, 
      0U, // string length
      6,
      ACE_NTOHL (0x76616c75), 
      ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_any,

      10,
      ACE_NTOHL (0x73686f77), 
      ACE_NTOHL (0x4c616265), 
      ACE_NTOHL (0x6c000000),  // name = showLabel
      CORBA::tk_long,


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_HepRepAttValueList (
    CORBA::tk_alias,
    sizeof (_oc_HepRepAttValueList),
    (char *) &_oc_HepRepAttValueList,
    0,
    sizeof (HepRepAttValueList)
  );

::CORBA::TypeCode_ptr _tc_HepRepAttValueList =
  &_tc_TAO_tc_HepRepAttValueList;

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepPoint[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  20,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x6570506f), 
  ACE_NTOHL (0x696e743a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:HepRepPoint:1.0
  12,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x6570506f), 
  ACE_NTOHL (0x696e7400),  // name = HepRepPoint
  4, // member count
  2,
  ACE_NTOHL (0x78000000),  // name = x
  CORBA::tk_double,

  2,
  ACE_NTOHL (0x79000000),  // name = y
  CORBA::tk_double,

  2,
  ACE_NTOHL (0x7a000000),  // name = z
  CORBA::tk_double,

  10,
  ACE_NTOHL (0x61747456), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x73000000),  // name = attValues
  CORBA::tk_alias, // typecode kind for typedefs
  196, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65704174), 
    ACE_NTOHL (0x7456616c), 
    ACE_NTOHL (0x75654c69), 
    ACE_NTOHL (0x73743a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValueList:1.0
    19,
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65704174), 
    ACE_NTOHL (0x7456616c), 
    ACE_NTOHL (0x75654c69), 
    ACE_NTOHL (0x73740000),  // name = HepRepAttValueList
    CORBA::tk_sequence, // typecode kind
    128, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      112, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        23,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x7456616c), 
        ACE_NTOHL (0x75653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValue:1.0
        15,
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x7456616c), 
        ACE_NTOHL (0x75650000),  // name = HepRepAttValue
        3, // member count
        5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_string, 
        0U, // string length
        6,
        ACE_NTOHL (0x76616c75), 
        ACE_NTOHL (0x65000000),  // name = value
        CORBA::tk_any,

        10,
        ACE_NTOHL (0x73686f77), 
        ACE_NTOHL (0x4c616265), 
        ACE_NTOHL (0x6c000000),  // name = showLabel
        CORBA::tk_long,


      0U,


};

static CORBA::TypeCode _tc_TAO_tc_HepRepPoint (
    CORBA::tk_struct,
    sizeof (_oc_HepRepPoint),
    (char *) &_oc_HepRepPoint,
    0,
    sizeof (HepRepPoint)
  );

::CORBA::TypeCode_ptr _tc_HepRepPoint =
  &_tc_TAO_tc_HepRepPoint;

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:67

void HepRepPoint::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepPoint *tmp = ACE_static_cast (HepRepPoint*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPPOINTLIST_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPPOINTLIST_CS_

void
_TAO_Unbounded_Sequence_HepRepPointList::_allocate_buffer (CORBA::ULong length)
{
  HepRepPoint* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_HepRepPointList::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      HepRepPoint *old =
        ACE_reinterpret_cast (HepRepPoint *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_HepRepPointList::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_HepRepPointList::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  HepRepPoint *tmp =
    ACE_reinterpret_cast (HepRepPoint *, this->buffer_);
  _TAO_Unbounded_Sequence_HepRepPointList::freebuf (tmp);
  this->buffer_ = 0;
} 

_TAO_Unbounded_Sequence_HepRepPointList::~_TAO_Unbounded_Sequence_HepRepPointList (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPPOINTLIST_CS_)
#define _HEPREPPOINTLIST_CS_

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// HepRepPointList
// *************************************************************

HepRepPointList::HepRepPointList (void)
{}

HepRepPointList::HepRepPointList (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepPointList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepPoint>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

HepRepPointList::HepRepPointList (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepPoint *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepPointList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepPoint>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

HepRepPointList::HepRepPointList (const HepRepPointList &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepPointList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepPoint>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

HepRepPointList::~HepRepPointList (void) // dtor
{}

void HepRepPointList::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepPointList *tmp = ACE_static_cast (HepRepPointList*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepPointList[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  24,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x6570506f), 
  ACE_NTOHL (0x696e744c), 
  ACE_NTOHL (0x6973743a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:HepRepPointList:1.0
  16,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x6570506f), 
  ACE_NTOHL (0x696e744c), 
  ACE_NTOHL (0x69737400),  // name = HepRepPointList
  CORBA::tk_sequence, // typecode kind
  320, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    304, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      20,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x6570506f), 
      ACE_NTOHL (0x696e743a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:HepRepPoint:1.0
      12,
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x6570506f), 
      ACE_NTOHL (0x696e7400),  // name = HepRepPoint
      4, // member count
      2,
      ACE_NTOHL (0x78000000),  // name = x
      CORBA::tk_double,

      2,
      ACE_NTOHL (0x79000000),  // name = y
      CORBA::tk_double,

      2,
      ACE_NTOHL (0x7a000000),  // name = z
      CORBA::tk_double,

      10,
      ACE_NTOHL (0x61747456), 
      ACE_NTOHL (0x616c7565), 
      ACE_NTOHL (0x73000000),  // name = attValues
      CORBA::tk_alias, // typecode kind for typedefs
      196, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x7456616c), 
        ACE_NTOHL (0x75654c69), 
        ACE_NTOHL (0x73743a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValueList:1.0
        19,
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x7456616c), 
        ACE_NTOHL (0x75654c69), 
        ACE_NTOHL (0x73740000),  // name = HepRepAttValueList
        CORBA::tk_sequence, // typecode kind
        128, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          112, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x48657052), 
            ACE_NTOHL (0x65704174), 
            ACE_NTOHL (0x7456616c), 
            ACE_NTOHL (0x75653a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValue:1.0
            15,
            ACE_NTOHL (0x48657052), 
            ACE_NTOHL (0x65704174), 
            ACE_NTOHL (0x7456616c), 
            ACE_NTOHL (0x75650000),  // name = HepRepAttValue
            3, // member count
            5,
            ACE_NTOHL (0x6e616d65), 
            ACE_NTOHL (0x0),  // name = name
            CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x76616c75), 
            ACE_NTOHL (0x65000000),  // name = value
            CORBA::tk_any,

            10,
            ACE_NTOHL (0x73686f77), 
            ACE_NTOHL (0x4c616265), 
            ACE_NTOHL (0x6c000000),  // name = showLabel
            CORBA::tk_long,


          0U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_HepRepPointList (
    CORBA::tk_alias,
    sizeof (_oc_HepRepPointList),
    (char *) &_oc_HepRepPointList,
    0,
    sizeof (HepRepPointList)
  );

::CORBA::TypeCode_ptr _tc_HepRepPointList =
  &_tc_TAO_tc_HepRepPointList;

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepInstance[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  23,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x6570496e), 
  ACE_NTOHL (0x7374616e), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepInstance:1.0
  15,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x6570496e), 
  ACE_NTOHL (0x7374616e), 
  ACE_NTOHL (0x63650000),  // name = HepRepInstance
  4, // member count
  9,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x4e616d65), 
  ACE_NTOHL (0x0),  // name = typeName
  CORBA::tk_string, 
  0U, // string length
  10,
  ACE_NTOHL (0x696e7374), 
  ACE_NTOHL (0x616e6365), 
  ACE_NTOHL (0x73000000),  // name = instances
  CORBA::tk_sequence, // typecode kind
  16, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    0xffffffff, // indirection
    0xffffff88, // negative offset (-120)
    0U,

  7,
  ACE_NTOHL (0x706f696e), 
  ACE_NTOHL (0x74730000),  // name = points
  CORBA::tk_alias, // typecode kind for typedefs
  380, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    24,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x6570506f), 
    ACE_NTOHL (0x696e744c), 
    ACE_NTOHL (0x6973743a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:HepRepPointList:1.0
    16,
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x6570506f), 
    ACE_NTOHL (0x696e744c), 
    ACE_NTOHL (0x69737400),  // name = HepRepPointList
    CORBA::tk_sequence, // typecode kind
    320, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      304, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        20,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x6570506f), 
        ACE_NTOHL (0x696e743a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:HepRepPoint:1.0
        12,
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x6570506f), 
        ACE_NTOHL (0x696e7400),  // name = HepRepPoint
        4, // member count
        2,
        ACE_NTOHL (0x78000000),  // name = x
        CORBA::tk_double,

        2,
        ACE_NTOHL (0x79000000),  // name = y
        CORBA::tk_double,

        2,
        ACE_NTOHL (0x7a000000),  // name = z
        CORBA::tk_double,

        10,
        ACE_NTOHL (0x61747456), 
        ACE_NTOHL (0x616c7565), 
        ACE_NTOHL (0x73000000),  // name = attValues
        CORBA::tk_alias, // typecode kind for typedefs
        196, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          27,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x48657052), 
          ACE_NTOHL (0x65704174), 
          ACE_NTOHL (0x7456616c), 
          ACE_NTOHL (0x75654c69), 
          ACE_NTOHL (0x73743a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValueList:1.0
          19,
          ACE_NTOHL (0x48657052), 
          ACE_NTOHL (0x65704174), 
          ACE_NTOHL (0x7456616c), 
          ACE_NTOHL (0x75654c69), 
          ACE_NTOHL (0x73740000),  // name = HepRepAttValueList
          CORBA::tk_sequence, // typecode kind
          128, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            112, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x48657052), 
              ACE_NTOHL (0x65704174), 
              ACE_NTOHL (0x7456616c), 
              ACE_NTOHL (0x75653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValue:1.0
              15,
              ACE_NTOHL (0x48657052), 
              ACE_NTOHL (0x65704174), 
              ACE_NTOHL (0x7456616c), 
              ACE_NTOHL (0x75650000),  // name = HepRepAttValue
              3, // member count
              5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
              CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x76616c75), 
              ACE_NTOHL (0x65000000),  // name = value
              CORBA::tk_any,

              10,
              ACE_NTOHL (0x73686f77), 
              ACE_NTOHL (0x4c616265), 
              ACE_NTOHL (0x6c000000),  // name = showLabel
              CORBA::tk_long,


            0U,



      0U,


  10,
  ACE_NTOHL (0x61747456), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x73000000),  // name = attValues
  0xffffffff, // indirection
  0xffffff1c, // negative offset (-228)
};

static CORBA::TypeCode _tc_TAO_tc_HepRepInstance (
    CORBA::tk_struct,
    sizeof (_oc_HepRepInstance),
    (char *) &_oc_HepRepInstance,
    0,
    sizeof (HepRepInstance)
  );

::CORBA::TypeCode_ptr _tc_HepRepInstance =
  &_tc_TAO_tc_HepRepInstance;

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:67

void HepRepInstance::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepInstance *tmp = ACE_static_cast (HepRepInstance*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPINSTANCE__TAO_SEQ_HEPREPINSTANCE_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPINSTANCE__TAO_SEQ_HEPREPINSTANCE_CS_

void
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::_allocate_buffer (CORBA::ULong length)
{
  HepRepInstance* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      HepRepInstance *old =
        ACE_reinterpret_cast (HepRepInstance *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  HepRepInstance *tmp =
    ACE_reinterpret_cast (HepRepInstance *, this->buffer_);
  _TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::freebuf (tmp);
  this->buffer_ = 0;
} 

HepRepInstance::_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance::~_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPINSTANCE__TAO_SEQ_HEPREPINSTANCE_CS_)
#define _HEPREPINSTANCE__TAO_SEQ_HEPREPINSTANCE_CS_

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// HepRepInstance::_tao_seq_HepRepInstance
// *************************************************************

HepRepInstance::_tao_seq_HepRepInstance::_tao_seq_HepRepInstance (void)
{}

HepRepInstance::_tao_seq_HepRepInstance::_tao_seq_HepRepInstance (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepInstance>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

HepRepInstance::_tao_seq_HepRepInstance::_tao_seq_HepRepInstance (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepInstance *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepInstance>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

HepRepInstance::_tao_seq_HepRepInstance::_tao_seq_HepRepInstance (const _tao_seq_HepRepInstance &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepInstance__tao_seq_HepRepInstance
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepInstance>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

HepRepInstance::_tao_seq_HepRepInstance::~_tao_seq_HepRepInstance (void) // dtor
{}

void HepRepInstance::_tao_seq_HepRepInstance::_tao_any_destructor (void *_tao_void_pointer)
{
  _tao_seq_HepRepInstance *tmp = ACE_static_cast (_tao_seq_HepRepInstance*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPINSTANCELIST_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPINSTANCELIST_CS_

void
_TAO_Unbounded_Sequence_HepRepInstanceList::_allocate_buffer (CORBA::ULong length)
{
  HepRepInstance* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_HepRepInstanceList::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      HepRepInstance *old =
        ACE_reinterpret_cast (HepRepInstance *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_HepRepInstanceList::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_HepRepInstanceList::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  HepRepInstance *tmp =
    ACE_reinterpret_cast (HepRepInstance *, this->buffer_);
  _TAO_Unbounded_Sequence_HepRepInstanceList::freebuf (tmp);
  this->buffer_ = 0;
} 

_TAO_Unbounded_Sequence_HepRepInstanceList::~_TAO_Unbounded_Sequence_HepRepInstanceList (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPINSTANCELIST_CS_)
#define _HEPREPINSTANCELIST_CS_

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// HepRepInstanceList
// *************************************************************

HepRepInstanceList::HepRepInstanceList (void)
{}

HepRepInstanceList::HepRepInstanceList (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepInstanceList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepInstance>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

HepRepInstanceList::HepRepInstanceList (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepInstance *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepInstanceList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepInstance>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

HepRepInstanceList::HepRepInstanceList (const HepRepInstanceList &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepInstanceList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepInstance>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

HepRepInstanceList::~HepRepInstanceList (void) // dtor
{}

void HepRepInstanceList::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepInstanceList *tmp = ACE_static_cast (HepRepInstanceList*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepInstanceList[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x6570496e), 
  ACE_NTOHL (0x7374616e), 
  ACE_NTOHL (0x63654c69), 
  ACE_NTOHL (0x73743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepInstanceList:1.0
  19,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x6570496e), 
  ACE_NTOHL (0x7374616e), 
  ACE_NTOHL (0x63654c69), 
  ACE_NTOHL (0x73740000),  // name = HepRepInstanceList
  CORBA::tk_sequence, // typecode kind
  560, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    544, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      23,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x6570496e), 
      ACE_NTOHL (0x7374616e), 
      ACE_NTOHL (0x63653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepInstance:1.0
      15,
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x6570496e), 
      ACE_NTOHL (0x7374616e), 
      ACE_NTOHL (0x63650000),  // name = HepRepInstance
      4, // member count
      9,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x4e616d65), 
      ACE_NTOHL (0x0),  // name = typeName
      CORBA::tk_string, 
      0U, // string length
      10,
      ACE_NTOHL (0x696e7374), 
      ACE_NTOHL (0x616e6365), 
      ACE_NTOHL (0x73000000),  // name = instances
      CORBA::tk_sequence, // typecode kind
      16, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        0xffffffff, // indirection
        0xffffff88, // negative offset (-120)
        0U,

      7,
      ACE_NTOHL (0x706f696e), 
      ACE_NTOHL (0x74730000),  // name = points
      CORBA::tk_alias, // typecode kind for typedefs
      380, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        24,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x6570506f), 
        ACE_NTOHL (0x696e744c), 
        ACE_NTOHL (0x6973743a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:HepRepPointList:1.0
        16,
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x6570506f), 
        ACE_NTOHL (0x696e744c), 
        ACE_NTOHL (0x69737400),  // name = HepRepPointList
        CORBA::tk_sequence, // typecode kind
        320, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          304, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            20,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x48657052), 
            ACE_NTOHL (0x6570506f), 
            ACE_NTOHL (0x696e743a), 
            ACE_NTOHL (0x312e3000),  // repository ID = IDL:HepRepPoint:1.0
            12,
            ACE_NTOHL (0x48657052), 
            ACE_NTOHL (0x6570506f), 
            ACE_NTOHL (0x696e7400),  // name = HepRepPoint
            4, // member count
            2,
            ACE_NTOHL (0x78000000),  // name = x
            CORBA::tk_double,

            2,
            ACE_NTOHL (0x79000000),  // name = y
            CORBA::tk_double,

            2,
            ACE_NTOHL (0x7a000000),  // name = z
            CORBA::tk_double,

            10,
            ACE_NTOHL (0x61747456), 
            ACE_NTOHL (0x616c7565), 
            ACE_NTOHL (0x73000000),  // name = attValues
            CORBA::tk_alias, // typecode kind for typedefs
            196, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              27,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x48657052), 
              ACE_NTOHL (0x65704174), 
              ACE_NTOHL (0x7456616c), 
              ACE_NTOHL (0x75654c69), 
              ACE_NTOHL (0x73743a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValueList:1.0
              19,
              ACE_NTOHL (0x48657052), 
              ACE_NTOHL (0x65704174), 
              ACE_NTOHL (0x7456616c), 
              ACE_NTOHL (0x75654c69), 
              ACE_NTOHL (0x73740000),  // name = HepRepAttValueList
              CORBA::tk_sequence, // typecode kind
              128, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                112, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x48657052), 
                  ACE_NTOHL (0x65704174), 
                  ACE_NTOHL (0x7456616c), 
                  ACE_NTOHL (0x75653a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValue:1.0
                  15,
                  ACE_NTOHL (0x48657052), 
                  ACE_NTOHL (0x65704174), 
                  ACE_NTOHL (0x7456616c), 
                  ACE_NTOHL (0x75650000),  // name = HepRepAttValue
                  3, // member count
                  5,
                  ACE_NTOHL (0x6e616d65), 
                  ACE_NTOHL (0x0),  // name = name
                  CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x76616c75), 
                  ACE_NTOHL (0x65000000),  // name = value
                  CORBA::tk_any,

                  10,
                  ACE_NTOHL (0x73686f77), 
                  ACE_NTOHL (0x4c616265), 
                  ACE_NTOHL (0x6c000000),  // name = showLabel
                  CORBA::tk_long,


                0U,



          0U,


      10,
      ACE_NTOHL (0x61747456), 
      ACE_NTOHL (0x616c7565), 
      ACE_NTOHL (0x73000000),  // name = attValues
      0xffffffff, // indirection
      0xffffff1c, // negative offset (-228)

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_HepRepInstanceList (
    CORBA::tk_alias,
    sizeof (_oc_HepRepInstanceList),
    (char *) &_oc_HepRepInstanceList,
    0,
    sizeof (HepRepInstanceList)
  );

::CORBA::TypeCode_ptr _tc_HepRepInstanceList =
  &_tc_TAO_tc_HepRepInstanceList;

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepTreeID[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  21,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65705472), 
  ACE_NTOHL (0x65654944), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:HepRepTreeID:1.0
  13,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65705472), 
  ACE_NTOHL (0x65654944), 
  ACE_NTOHL (0x0),  // name = HepRepTreeID
  2, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_string, 
  0U, // string length
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_HepRepTreeID (
    CORBA::tk_struct,
    sizeof (_oc_HepRepTreeID),
    (char *) &_oc_HepRepTreeID,
    0,
    sizeof (HepRepTreeID)
  );

::CORBA::TypeCode_ptr _tc_HepRepTreeID =
  &_tc_TAO_tc_HepRepTreeID;

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:67

void HepRepTreeID::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepTreeID *tmp = ACE_static_cast (HepRepTreeID*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPTREEIDLIST_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPTREEIDLIST_CS_

void
_TAO_Unbounded_Sequence_HepRepTreeIDList::_allocate_buffer (CORBA::ULong length)
{
  HepRepTreeID* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_HepRepTreeIDList::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      HepRepTreeID *old =
        ACE_reinterpret_cast (HepRepTreeID *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_HepRepTreeIDList::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_HepRepTreeIDList::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  HepRepTreeID *tmp =
    ACE_reinterpret_cast (HepRepTreeID *, this->buffer_);
  _TAO_Unbounded_Sequence_HepRepTreeIDList::freebuf (tmp);
  this->buffer_ = 0;
} 

_TAO_Unbounded_Sequence_HepRepTreeIDList::~_TAO_Unbounded_Sequence_HepRepTreeIDList (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPTREEIDLIST_CS_)
#define _HEPREPTREEIDLIST_CS_

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// HepRepTreeIDList
// *************************************************************

HepRepTreeIDList::HepRepTreeIDList (void)
{}

HepRepTreeIDList::HepRepTreeIDList (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepTreeIDList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepTreeID>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

HepRepTreeIDList::HepRepTreeIDList (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepTreeID *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepTreeIDList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepTreeID>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

HepRepTreeIDList::HepRepTreeIDList (const HepRepTreeIDList &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepTreeIDList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepTreeID>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

HepRepTreeIDList::~HepRepTreeIDList (void) // dtor
{}

void HepRepTreeIDList::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepTreeIDList *tmp = ACE_static_cast (HepRepTreeIDList*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepTreeIDList[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  25,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65705472), 
  ACE_NTOHL (0x65654944), 
  ACE_NTOHL (0x4c697374), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:HepRepTreeIDList:1.0
  17,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65705472), 
  ACE_NTOHL (0x65654944), 
  ACE_NTOHL (0x4c697374), 
  ACE_NTOHL (0x0),  // name = HepRepTreeIDList
  CORBA::tk_sequence, // typecode kind
  112, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    96, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      21,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x65705472), 
      ACE_NTOHL (0x65654944), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:HepRepTreeID:1.0
      13,
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x65705472), 
      ACE_NTOHL (0x65654944), 
      ACE_NTOHL (0x0),  // name = HepRepTreeID
      2, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_string, 
      0U, // string length
      8,
      ACE_NTOHL (0x76657273), 
      ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_string, 
      0U, // string length

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_HepRepTreeIDList (
    CORBA::tk_alias,
    sizeof (_oc_HepRepTreeIDList),
    (char *) &_oc_HepRepTreeIDList,
    0,
    sizeof (HepRepTreeIDList)
  );

::CORBA::TypeCode_ptr _tc_HepRepTreeIDList =
  &_tc_TAO_tc_HepRepTreeIDList;

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepInstanceTree[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x6570496e), 
  ACE_NTOHL (0x7374616e), 
  ACE_NTOHL (0x63655472), 
  ACE_NTOHL (0x65653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepInstanceTree:1.0
  19,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x6570496e), 
  ACE_NTOHL (0x7374616e), 
  ACE_NTOHL (0x63655472), 
  ACE_NTOHL (0x65650000),  // name = HepRepInstanceTree
  4, // member count
  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_struct, // typecode kind
  96, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    21,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65705472), 
    ACE_NTOHL (0x65654944), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:HepRepTreeID:1.0
    13,
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65705472), 
    ACE_NTOHL (0x65654944), 
    ACE_NTOHL (0x0),  // name = HepRepTreeID
    2, // member count
    5,
    ACE_NTOHL (0x6e616d65), 
    ACE_NTOHL (0x0),  // name = name
    CORBA::tk_string, 
    0U, // string length
    8,
    ACE_NTOHL (0x76657273), 
    ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x54726565), 
  ACE_NTOHL (0x49440000),  // name = typeTreeID
  0xffffffff, // indirection
  0xffffff84, // negative offset (-124)
  16,
  ACE_NTOHL (0x696e7374), 
  ACE_NTOHL (0x616e6365), 
  ACE_NTOHL (0x54726565), 
  ACE_NTOHL (0x49447300),  // name = instanceTreeIDs
  CORBA::tk_alias, // typecode kind for typedefs
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    25,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65705472), 
    ACE_NTOHL (0x65654944), 
    ACE_NTOHL (0x4c697374), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:HepRepTreeIDList:1.0
    17,
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65705472), 
    ACE_NTOHL (0x65654944), 
    ACE_NTOHL (0x4c697374), 
    ACE_NTOHL (0x0),  // name = HepRepTreeIDList
    CORBA::tk_sequence, // typecode kind
    16, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      0xffffffff, // indirection
      0xffffff18, // negative offset (-232)
      0U,


  10,
  ACE_NTOHL (0x696e7374), 
  ACE_NTOHL (0x616e6365), 
  ACE_NTOHL (0x73000000),  // name = instances
  CORBA::tk_alias, // typecode kind for typedefs
  628, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x6570496e), 
    ACE_NTOHL (0x7374616e), 
    ACE_NTOHL (0x63654c69), 
    ACE_NTOHL (0x73743a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepInstanceList:1.0
    19,
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x6570496e), 
    ACE_NTOHL (0x7374616e), 
    ACE_NTOHL (0x63654c69), 
    ACE_NTOHL (0x73740000),  // name = HepRepInstanceList
    CORBA::tk_sequence, // typecode kind
    560, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      544, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        23,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x6570496e), 
        ACE_NTOHL (0x7374616e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepInstance:1.0
        15,
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x6570496e), 
        ACE_NTOHL (0x7374616e), 
        ACE_NTOHL (0x63650000),  // name = HepRepInstance
        4, // member count
        9,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = typeName
        CORBA::tk_string, 
        0U, // string length
        10,
        ACE_NTOHL (0x696e7374), 
        ACE_NTOHL (0x616e6365), 
        ACE_NTOHL (0x73000000),  // name = instances
        CORBA::tk_sequence, // typecode kind
        16, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          0xffffffff, // indirection
          0xffffff88, // negative offset (-120)
          0U,

        7,
        ACE_NTOHL (0x706f696e), 
        ACE_NTOHL (0x74730000),  // name = points
        CORBA::tk_alias, // typecode kind for typedefs
        380, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          24,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x48657052), 
          ACE_NTOHL (0x6570506f), 
          ACE_NTOHL (0x696e744c), 
          ACE_NTOHL (0x6973743a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:HepRepPointList:1.0
          16,
          ACE_NTOHL (0x48657052), 
          ACE_NTOHL (0x6570506f), 
          ACE_NTOHL (0x696e744c), 
          ACE_NTOHL (0x69737400),  // name = HepRepPointList
          CORBA::tk_sequence, // typecode kind
          320, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            304, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              20,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x48657052), 
              ACE_NTOHL (0x6570506f), 
              ACE_NTOHL (0x696e743a), 
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:HepRepPoint:1.0
              12,
              ACE_NTOHL (0x48657052), 
              ACE_NTOHL (0x6570506f), 
              ACE_NTOHL (0x696e7400),  // name = HepRepPoint
              4, // member count
              2,
              ACE_NTOHL (0x78000000),  // name = x
              CORBA::tk_double,

              2,
              ACE_NTOHL (0x79000000),  // name = y
              CORBA::tk_double,

              2,
              ACE_NTOHL (0x7a000000),  // name = z
              CORBA::tk_double,

              10,
              ACE_NTOHL (0x61747456), 
              ACE_NTOHL (0x616c7565), 
              ACE_NTOHL (0x73000000),  // name = attValues
              CORBA::tk_alias, // typecode kind for typedefs
              196, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                27,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x48657052), 
                ACE_NTOHL (0x65704174), 
                ACE_NTOHL (0x7456616c), 
                ACE_NTOHL (0x75654c69), 
                ACE_NTOHL (0x73743a31), 
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValueList:1.0
                19,
                ACE_NTOHL (0x48657052), 
                ACE_NTOHL (0x65704174), 
                ACE_NTOHL (0x7456616c), 
                ACE_NTOHL (0x75654c69), 
                ACE_NTOHL (0x73740000),  // name = HepRepAttValueList
                CORBA::tk_sequence, // typecode kind
                128, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  CORBA::tk_struct, // typecode kind
                  112, // encapsulation length
                    TAO_ENCAP_BYTE_ORDER, // byte order
                    23,
                    ACE_NTOHL (0x49444c3a), 
                    ACE_NTOHL (0x48657052), 
                    ACE_NTOHL (0x65704174), 
                    ACE_NTOHL (0x7456616c), 
                    ACE_NTOHL (0x75653a31), 
                    ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValue:1.0
                    15,
                    ACE_NTOHL (0x48657052), 
                    ACE_NTOHL (0x65704174), 
                    ACE_NTOHL (0x7456616c), 
                    ACE_NTOHL (0x75650000),  // name = HepRepAttValue
                    3, // member count
                    5,
                    ACE_NTOHL (0x6e616d65), 
                    ACE_NTOHL (0x0),  // name = name
                    CORBA::tk_string, 
                    0U, // string length
                    6,
                    ACE_NTOHL (0x76616c75), 
                    ACE_NTOHL (0x65000000),  // name = value
                    CORBA::tk_any,

                    10,
                    ACE_NTOHL (0x73686f77), 
                    ACE_NTOHL (0x4c616265), 
                    ACE_NTOHL (0x6c000000),  // name = showLabel
                    CORBA::tk_long,


                  0U,



            0U,


        10,
        ACE_NTOHL (0x61747456), 
        ACE_NTOHL (0x616c7565), 
        ACE_NTOHL (0x73000000),  // name = attValues
        0xffffffff, // indirection
        0xffffff1c, // negative offset (-228)

      0U,


};

static CORBA::TypeCode _tc_TAO_tc_HepRepInstanceTree (
    CORBA::tk_struct,
    sizeof (_oc_HepRepInstanceTree),
    (char *) &_oc_HepRepInstanceTree,
    0,
    sizeof (HepRepInstanceTree)
  );

::CORBA::TypeCode_ptr _tc_HepRepInstanceTree =
  &_tc_TAO_tc_HepRepInstanceTree;

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:67

void HepRepInstanceTree::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepInstanceTree *tmp = ACE_static_cast (HepRepInstanceTree*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepType[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  19,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65705479), 
  ACE_NTOHL (0x70653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepType:1.0
  11,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65705479), 
  ACE_NTOHL (0x70650000),  // name = HepRepType
  6, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_string, 
  0U, // string length
  5,
  ACE_NTOHL (0x64657363), 
  ACE_NTOHL (0x0),  // name = desc
  CORBA::tk_string, 
  0U, // string length
  8,
  ACE_NTOHL (0x696e666f), 
  ACE_NTOHL (0x55524c00),  // name = infoURL
  CORBA::tk_string, 
  0U, // string length
  6,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x73000000),  // name = types
  CORBA::tk_sequence, // typecode kind
  16, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    0xffffffff, // indirection
    0xffffff70, // negative offset (-144)
    0U,

  8,
  ACE_NTOHL (0x61747444), 
  ACE_NTOHL (0x65667300),  // name = attDefs
  CORBA::tk_alias, // typecode kind for typedefs
  224, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    25,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65704174), 
    ACE_NTOHL (0x74446566), 
    ACE_NTOHL (0x4c697374), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAttDefList:1.0
    17,
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65704174), 
    ACE_NTOHL (0x74446566), 
    ACE_NTOHL (0x4c697374), 
    ACE_NTOHL (0x0),  // name = HepRepAttDefList
    CORBA::tk_sequence, // typecode kind
    156, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      140, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        21,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x74446566), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAttDef:1.0
        13,
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x74446566), 
        ACE_NTOHL (0x0),  // name = HepRepAttDef
        4, // member count
        5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_string, 
        0U, // string length
        5,
        ACE_NTOHL (0x64657363), 
        ACE_NTOHL (0x0),  // name = desc
        CORBA::tk_string, 
        0U, // string length
        9,
        ACE_NTOHL (0x63617465), 
        ACE_NTOHL (0x676f7279), 
        ACE_NTOHL (0x0),  // name = category
        CORBA::tk_string, 
        0U, // string length
        6,
        ACE_NTOHL (0x65787472), 
        ACE_NTOHL (0x61000000),  // name = extra
        CORBA::tk_string, 
        0U, // string length

      0U,


  10,
  ACE_NTOHL (0x61747456), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x73000000),  // name = attValues
  CORBA::tk_alias, // typecode kind for typedefs
  196, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65704174), 
    ACE_NTOHL (0x7456616c), 
    ACE_NTOHL (0x75654c69), 
    ACE_NTOHL (0x73743a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValueList:1.0
    19,
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65704174), 
    ACE_NTOHL (0x7456616c), 
    ACE_NTOHL (0x75654c69), 
    ACE_NTOHL (0x73740000),  // name = HepRepAttValueList
    CORBA::tk_sequence, // typecode kind
    128, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      112, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        23,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x7456616c), 
        ACE_NTOHL (0x75653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValue:1.0
        15,
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x7456616c), 
        ACE_NTOHL (0x75650000),  // name = HepRepAttValue
        3, // member count
        5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_string, 
        0U, // string length
        6,
        ACE_NTOHL (0x76616c75), 
        ACE_NTOHL (0x65000000),  // name = value
        CORBA::tk_any,

        10,
        ACE_NTOHL (0x73686f77), 
        ACE_NTOHL (0x4c616265), 
        ACE_NTOHL (0x6c000000),  // name = showLabel
        CORBA::tk_long,


      0U,


};

static CORBA::TypeCode _tc_TAO_tc_HepRepType (
    CORBA::tk_struct,
    sizeof (_oc_HepRepType),
    (char *) &_oc_HepRepType,
    0,
    sizeof (HepRepType)
  );

::CORBA::TypeCode_ptr _tc_HepRepType =
  &_tc_TAO_tc_HepRepType;

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:67

void HepRepType::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepType *tmp = ACE_static_cast (HepRepType*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPTYPE__TAO_SEQ_HEPREPTYPE_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPTYPE__TAO_SEQ_HEPREPTYPE_CS_

void
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::_allocate_buffer (CORBA::ULong length)
{
  HepRepType* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      HepRepType *old =
        ACE_reinterpret_cast (HepRepType *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  HepRepType *tmp =
    ACE_reinterpret_cast (HepRepType *, this->buffer_);
  _TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::freebuf (tmp);
  this->buffer_ = 0;
} 

HepRepType::_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType::~_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPTYPE__TAO_SEQ_HEPREPTYPE_CS_)
#define _HEPREPTYPE__TAO_SEQ_HEPREPTYPE_CS_

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// HepRepType::_tao_seq_HepRepType
// *************************************************************

HepRepType::_tao_seq_HepRepType::_tao_seq_HepRepType (void)
{}

HepRepType::_tao_seq_HepRepType::_tao_seq_HepRepType (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepType>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

HepRepType::_tao_seq_HepRepType::_tao_seq_HepRepType (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepType *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepType>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

HepRepType::_tao_seq_HepRepType::_tao_seq_HepRepType (const _tao_seq_HepRepType &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepType__tao_seq_HepRepType
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepType>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

HepRepType::_tao_seq_HepRepType::~_tao_seq_HepRepType (void) // dtor
{}

void HepRepType::_tao_seq_HepRepType::_tao_any_destructor (void *_tao_void_pointer)
{
  _tao_seq_HepRepType *tmp = ACE_static_cast (_tao_seq_HepRepType*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPTYPELIST_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPTYPELIST_CS_

void
_TAO_Unbounded_Sequence_HepRepTypeList::_allocate_buffer (CORBA::ULong length)
{
  HepRepType* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_HepRepTypeList::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      HepRepType *old =
        ACE_reinterpret_cast (HepRepType *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_HepRepTypeList::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_HepRepTypeList::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  HepRepType *tmp =
    ACE_reinterpret_cast (HepRepType *, this->buffer_);
  _TAO_Unbounded_Sequence_HepRepTypeList::freebuf (tmp);
  this->buffer_ = 0;
} 

_TAO_Unbounded_Sequence_HepRepTypeList::~_TAO_Unbounded_Sequence_HepRepTypeList (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPTYPELIST_CS_)
#define _HEPREPTYPELIST_CS_

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// HepRepTypeList
// *************************************************************

HepRepTypeList::HepRepTypeList (void)
{}

HepRepTypeList::HepRepTypeList (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepTypeList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepType>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

HepRepTypeList::HepRepTypeList (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepType *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepTypeList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepType>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

HepRepTypeList::HepRepTypeList (const HepRepTypeList &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepTypeList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepType>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

HepRepTypeList::~HepRepTypeList (void) // dtor
{}

void HepRepTypeList::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepTypeList *tmp = ACE_static_cast (HepRepTypeList*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepTypeList[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  23,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65705479), 
  ACE_NTOHL (0x70654c69), 
  ACE_NTOHL (0x73743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepTypeList:1.0
  15,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65705479), 
  ACE_NTOHL (0x70654c69), 
  ACE_NTOHL (0x73740000),  // name = HepRepTypeList
  CORBA::tk_sequence, // typecode kind
  624, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    608, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      19,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x65705479), 
      ACE_NTOHL (0x70653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepType:1.0
      11,
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x65705479), 
      ACE_NTOHL (0x70650000),  // name = HepRepType
      6, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_string, 
      0U, // string length
      5,
      ACE_NTOHL (0x64657363), 
      ACE_NTOHL (0x0),  // name = desc
      CORBA::tk_string, 
      0U, // string length
      8,
      ACE_NTOHL (0x696e666f), 
      ACE_NTOHL (0x55524c00),  // name = infoURL
      CORBA::tk_string, 
      0U, // string length
      6,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x73000000),  // name = types
      CORBA::tk_sequence, // typecode kind
      16, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        0xffffffff, // indirection
        0xffffff70, // negative offset (-144)
        0U,

      8,
      ACE_NTOHL (0x61747444), 
      ACE_NTOHL (0x65667300),  // name = attDefs
      CORBA::tk_alias, // typecode kind for typedefs
      224, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        25,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x74446566), 
        ACE_NTOHL (0x4c697374), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAttDefList:1.0
        17,
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x74446566), 
        ACE_NTOHL (0x4c697374), 
        ACE_NTOHL (0x0),  // name = HepRepAttDefList
        CORBA::tk_sequence, // typecode kind
        156, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          140, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            21,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x48657052), 
            ACE_NTOHL (0x65704174), 
            ACE_NTOHL (0x74446566), 
            ACE_NTOHL (0x3a312e30), 
            ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAttDef:1.0
            13,
            ACE_NTOHL (0x48657052), 
            ACE_NTOHL (0x65704174), 
            ACE_NTOHL (0x74446566), 
            ACE_NTOHL (0x0),  // name = HepRepAttDef
            4, // member count
            5,
            ACE_NTOHL (0x6e616d65), 
            ACE_NTOHL (0x0),  // name = name
            CORBA::tk_string, 
            0U, // string length
            5,
            ACE_NTOHL (0x64657363), 
            ACE_NTOHL (0x0),  // name = desc
            CORBA::tk_string, 
            0U, // string length
            9,
            ACE_NTOHL (0x63617465), 
            ACE_NTOHL (0x676f7279), 
            ACE_NTOHL (0x0),  // name = category
            CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x65787472), 
            ACE_NTOHL (0x61000000),  // name = extra
            CORBA::tk_string, 
            0U, // string length

          0U,


      10,
      ACE_NTOHL (0x61747456), 
      ACE_NTOHL (0x616c7565), 
      ACE_NTOHL (0x73000000),  // name = attValues
      CORBA::tk_alias, // typecode kind for typedefs
      196, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x7456616c), 
        ACE_NTOHL (0x75654c69), 
        ACE_NTOHL (0x73743a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValueList:1.0
        19,
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65704174), 
        ACE_NTOHL (0x7456616c), 
        ACE_NTOHL (0x75654c69), 
        ACE_NTOHL (0x73740000),  // name = HepRepAttValueList
        CORBA::tk_sequence, // typecode kind
        128, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          112, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x48657052), 
            ACE_NTOHL (0x65704174), 
            ACE_NTOHL (0x7456616c), 
            ACE_NTOHL (0x75653a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValue:1.0
            15,
            ACE_NTOHL (0x48657052), 
            ACE_NTOHL (0x65704174), 
            ACE_NTOHL (0x7456616c), 
            ACE_NTOHL (0x75650000),  // name = HepRepAttValue
            3, // member count
            5,
            ACE_NTOHL (0x6e616d65), 
            ACE_NTOHL (0x0),  // name = name
            CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x76616c75), 
            ACE_NTOHL (0x65000000),  // name = value
            CORBA::tk_any,

            10,
            ACE_NTOHL (0x73686f77), 
            ACE_NTOHL (0x4c616265), 
            ACE_NTOHL (0x6c000000),  // name = showLabel
            CORBA::tk_long,


          0U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_HepRepTypeList (
    CORBA::tk_alias,
    sizeof (_oc_HepRepTypeList),
    (char *) &_oc_HepRepTypeList,
    0,
    sizeof (HepRepTypeList)
  );

::CORBA::TypeCode_ptr _tc_HepRepTypeList =
  &_tc_TAO_tc_HepRepTypeList;

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepTypeTree[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  23,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65705479), 
  ACE_NTOHL (0x70655472), 
  ACE_NTOHL (0x65653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepTypeTree:1.0
  15,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65705479), 
  ACE_NTOHL (0x70655472), 
  ACE_NTOHL (0x65650000),  // name = HepRepTypeTree
  2, // member count
  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_struct, // typecode kind
  96, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    21,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65705472), 
    ACE_NTOHL (0x65654944), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:HepRepTreeID:1.0
    13,
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65705472), 
    ACE_NTOHL (0x65654944), 
    ACE_NTOHL (0x0),  // name = HepRepTreeID
    2, // member count
    5,
    ACE_NTOHL (0x6e616d65), 
    ACE_NTOHL (0x0),  // name = name
    CORBA::tk_string, 
    0U, // string length
    8,
    ACE_NTOHL (0x76657273), 
    ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_string, 
    0U, // string length

  6,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x73000000),  // name = types
  CORBA::tk_alias, // typecode kind for typedefs
  684, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    23,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65705479), 
    ACE_NTOHL (0x70654c69), 
    ACE_NTOHL (0x73743a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepTypeList:1.0
    15,
    ACE_NTOHL (0x48657052), 
    ACE_NTOHL (0x65705479), 
    ACE_NTOHL (0x70654c69), 
    ACE_NTOHL (0x73740000),  // name = HepRepTypeList
    CORBA::tk_sequence, // typecode kind
    624, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      608, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        19,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65705479), 
        ACE_NTOHL (0x70653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepType:1.0
        11,
        ACE_NTOHL (0x48657052), 
        ACE_NTOHL (0x65705479), 
        ACE_NTOHL (0x70650000),  // name = HepRepType
        6, // member count
        5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_string, 
        0U, // string length
        5,
        ACE_NTOHL (0x64657363), 
        ACE_NTOHL (0x0),  // name = desc
        CORBA::tk_string, 
        0U, // string length
        8,
        ACE_NTOHL (0x696e666f), 
        ACE_NTOHL (0x55524c00),  // name = infoURL
        CORBA::tk_string, 
        0U, // string length
        6,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x73000000),  // name = types
        CORBA::tk_sequence, // typecode kind
        16, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          0xffffffff, // indirection
          0xffffff70, // negative offset (-144)
          0U,

        8,
        ACE_NTOHL (0x61747444), 
        ACE_NTOHL (0x65667300),  // name = attDefs
        CORBA::tk_alias, // typecode kind for typedefs
        224, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          25,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x48657052), 
          ACE_NTOHL (0x65704174), 
          ACE_NTOHL (0x74446566), 
          ACE_NTOHL (0x4c697374), 
          ACE_NTOHL (0x3a312e30), 
          ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAttDefList:1.0
          17,
          ACE_NTOHL (0x48657052), 
          ACE_NTOHL (0x65704174), 
          ACE_NTOHL (0x74446566), 
          ACE_NTOHL (0x4c697374), 
          ACE_NTOHL (0x0),  // name = HepRepAttDefList
          CORBA::tk_sequence, // typecode kind
          156, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            140, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              21,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x48657052), 
              ACE_NTOHL (0x65704174), 
              ACE_NTOHL (0x74446566), 
              ACE_NTOHL (0x3a312e30), 
              ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAttDef:1.0
              13,
              ACE_NTOHL (0x48657052), 
              ACE_NTOHL (0x65704174), 
              ACE_NTOHL (0x74446566), 
              ACE_NTOHL (0x0),  // name = HepRepAttDef
              4, // member count
              5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
              CORBA::tk_string, 
              0U, // string length
              5,
              ACE_NTOHL (0x64657363), 
              ACE_NTOHL (0x0),  // name = desc
              CORBA::tk_string, 
              0U, // string length
              9,
              ACE_NTOHL (0x63617465), 
              ACE_NTOHL (0x676f7279), 
              ACE_NTOHL (0x0),  // name = category
              CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x65787472), 
              ACE_NTOHL (0x61000000),  // name = extra
              CORBA::tk_string, 
              0U, // string length

            0U,


        10,
        ACE_NTOHL (0x61747456), 
        ACE_NTOHL (0x616c7565), 
        ACE_NTOHL (0x73000000),  // name = attValues
        CORBA::tk_alias, // typecode kind for typedefs
        196, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          27,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x48657052), 
          ACE_NTOHL (0x65704174), 
          ACE_NTOHL (0x7456616c), 
          ACE_NTOHL (0x75654c69), 
          ACE_NTOHL (0x73743a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValueList:1.0
          19,
          ACE_NTOHL (0x48657052), 
          ACE_NTOHL (0x65704174), 
          ACE_NTOHL (0x7456616c), 
          ACE_NTOHL (0x75654c69), 
          ACE_NTOHL (0x73740000),  // name = HepRepAttValueList
          CORBA::tk_sequence, // typecode kind
          128, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            112, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x48657052), 
              ACE_NTOHL (0x65704174), 
              ACE_NTOHL (0x7456616c), 
              ACE_NTOHL (0x75653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRepAttValue:1.0
              15,
              ACE_NTOHL (0x48657052), 
              ACE_NTOHL (0x65704174), 
              ACE_NTOHL (0x7456616c), 
              ACE_NTOHL (0x75650000),  // name = HepRepAttValue
              3, // member count
              5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
              CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x76616c75), 
              ACE_NTOHL (0x65000000),  // name = value
              CORBA::tk_any,

              10,
              ACE_NTOHL (0x73686f77), 
              ACE_NTOHL (0x4c616265), 
              ACE_NTOHL (0x6c000000),  // name = showLabel
              CORBA::tk_long,


            0U,



      0U,


};

static CORBA::TypeCode _tc_TAO_tc_HepRepTypeTree (
    CORBA::tk_struct,
    sizeof (_oc_HepRepTypeTree),
    (char *) &_oc_HepRepTypeTree,
    0,
    sizeof (HepRepTypeTree)
  );

::CORBA::TypeCode_ptr _tc_HepRepTypeTree =
  &_tc_TAO_tc_HepRepTypeTree;

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:67

void HepRepTypeTree::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepTypeTree *tmp = ACE_static_cast (HepRepTypeTree*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepAction[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  21,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704163), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAction:1.0
  13,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704163), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = HepRepAction
  2, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_string, 
  0U, // string length
  11,
  ACE_NTOHL (0x65787072), 
  ACE_NTOHL (0x65737369), 
  ACE_NTOHL (0x6f6e0000),  // name = expression
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_HepRepAction (
    CORBA::tk_struct,
    sizeof (_oc_HepRepAction),
    (char *) &_oc_HepRepAction,
    0,
    sizeof (HepRepAction)
  );

::CORBA::TypeCode_ptr _tc_HepRepAction =
  &_tc_TAO_tc_HepRepAction;

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:67

void HepRepAction::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepAction *tmp = ACE_static_cast (HepRepAction*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_HEPREPACTIONLIST_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_HEPREPACTIONLIST_CS_

void
_TAO_Unbounded_Sequence_HepRepActionList::_allocate_buffer (CORBA::ULong length)
{
  HepRepAction* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_HepRepActionList::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      HepRepAction *old =
        ACE_reinterpret_cast (HepRepAction *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_HepRepActionList::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
_TAO_Unbounded_Sequence_HepRepActionList::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  HepRepAction *tmp =
    ACE_reinterpret_cast (HepRepAction *, this->buffer_);
  _TAO_Unbounded_Sequence_HepRepActionList::freebuf (tmp);
  this->buffer_ = 0;
} 

_TAO_Unbounded_Sequence_HepRepActionList::~_TAO_Unbounded_Sequence_HepRepActionList (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_HEPREPACTIONLIST_CS_)
#define _HEPREPACTIONLIST_CS_

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// HepRepActionList
// *************************************************************

HepRepActionList::HepRepActionList (void)
{}

HepRepActionList::HepRepActionList (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepActionList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepAction>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

HepRepActionList::HepRepActionList (
    CORBA::ULong max,
    CORBA::ULong length,
    HepRepAction *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepActionList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepAction>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

HepRepActionList::HepRepActionList (const HepRepActionList &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_HepRepActionList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<HepRepAction>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

HepRepActionList::~HepRepActionList (void) // dtor
{}

void HepRepActionList::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRepActionList *tmp = ACE_static_cast (HepRepActionList*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRepActionList[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  25,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704163), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x4c697374), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:HepRepActionList:1.0
  17,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65704163), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x4c697374), 
  ACE_NTOHL (0x0),  // name = HepRepActionList
  CORBA::tk_sequence, // typecode kind
  116, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    100, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      21,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x65704163), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:HepRepAction:1.0
      13,
      ACE_NTOHL (0x48657052), 
      ACE_NTOHL (0x65704163), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x0),  // name = HepRepAction
      2, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_string, 
      0U, // string length
      11,
      ACE_NTOHL (0x65787072), 
      ACE_NTOHL (0x65737369), 
      ACE_NTOHL (0x6f6e0000),  // name = expression
      CORBA::tk_string, 
      0U, // string length

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_HepRepActionList (
    CORBA::tk_alias,
    sizeof (_oc_HepRepActionList),
    (char *) &_oc_HepRepActionList,
    0,
    sizeof (HepRepActionList)
  );

::CORBA::TypeCode_ptr _tc_HepRepActionList =
  &_tc_TAO_tc_HepRepActionList;

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:61

int HepRep::_tao_class_id = 0;

HepRep_ptr
tao_HepRep_duplicate (
    HepRep_ptr p
  )
{
  return HepRep::_duplicate (p);
}

void
tao_HepRep_release (
    HepRep_ptr p
  )
{
  CORBA::release (p);
}

HepRep_ptr
tao_HepRep_nil (
    void
  )
{
  return HepRep::_nil ();
}

HepRep_ptr
tao_HepRep_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return HepRep::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_HepRep_upcast (
    void *src
  )
{
  HepRep **tmp =
    ACE_static_cast (HepRep **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be\be_interface.cpp:715

// *************************************************************
// HepRep_var
// *************************************************************

HepRep_var::HepRep_var (void)
  : ptr_ (HepRep::_nil ())
{}

::HepRep_ptr
HepRep_var::ptr (void) const
{
  return this->ptr_;
}

HepRep_var::HepRep_var (const ::HepRep_var &p)
  : TAO_Base_var (),
    ptr_ (HepRep::_duplicate (p.ptr ()))
{}

HepRep_var::~HepRep_var (void)
{
  CORBA::release (this->ptr_);
}

HepRep_var &
HepRep_var::operator= (HepRep_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

HepRep_var &
HepRep_var::operator= (const ::HepRep_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::HepRep::_duplicate (p.ptr ());
  }
  return *this;
}

HepRep_var::operator const ::HepRep_ptr &() const // cast
{
  return this->ptr_;
}

HepRep_var::operator ::HepRep_ptr &() // cast 
{
  return this->ptr_;
}

::HepRep_ptr
HepRep_var::operator-> (void) const
{
  return this->ptr_;
}

::HepRep_ptr
HepRep_var::in (void) const
{
  return this->ptr_;
}

::HepRep_ptr &
HepRep_var::inout (void)
{
  return this->ptr_;
}

::HepRep_ptr &
HepRep_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::HepRep::_nil ();
  return this->ptr_;
}

::HepRep_ptr
HepRep_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::HepRep_ptr val = this->ptr_;
  this->ptr_ = ::HepRep::_nil ();
  return val;
}

::HepRep_ptr
HepRep_var::tao_duplicate (HepRep_ptr p)
{
  return ::HepRep::_duplicate (p);
}

void
HepRep_var::tao_release (HepRep_ptr p)
{
  CORBA::release (p);
}

::HepRep_ptr
HepRep_var::tao_nil (void)
{
  return ::HepRep::_nil ();
}

::HepRep_ptr
HepRep_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::HepRep::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
HepRep_var::tao_upcast (void *src)
{
  HepRep **tmp =
    ACE_static_cast (HepRep **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1024

// *************************************************************
// HepRep_out
// *************************************************************

HepRep_out::HepRep_out (HepRep_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::HepRep::_nil ();
}

HepRep_out::HepRep_out (HepRep_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::HepRep::_nil ();
}

HepRep_out::HepRep_out (const ::HepRep_out &p)
  : ptr_ (ACE_const_cast (HepRep_out &, p).ptr_)
{}

::HepRep_out &
HepRep_out::operator= (const ::HepRep_out &p)
{
  this->ptr_ = ACE_const_cast (HepRep_out&, p).ptr_;
  return *this;
}

HepRep_out &
HepRep_out::operator= (const ::HepRep_var &p)
{
  this->ptr_ = ::HepRep::_duplicate (p.ptr ());
  return *this;
}

HepRep_out &
HepRep_out::operator= (HepRep_ptr p)
{
  this->ptr_ = p;
  return *this;
}

HepRep_out::operator ::HepRep_ptr &() // cast
{
  return this->ptr_;
}

::HepRep_ptr &
HepRep_out::ptr (void)
{
  return this->ptr_;
}

::HepRep_ptr
HepRep_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_HepRep_getInstanceTreeTop : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_HepRep_getInstanceTreeTop (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * instanceTreeName,
      const char * instanceTreeVersion);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (::HepRepInstanceTree * result);
  
private:
  TAO_ClientRequestInfo_HepRep_getInstanceTreeTop (const TAO_ClientRequestInfo_HepRep_getInstanceTreeTop &);
  void operator= (const TAO_ClientRequestInfo_HepRep_getInstanceTreeTop &);
  const char * instanceTreeName_;
  const char * instanceTreeVersion_;
  
  ::HepRepInstanceTree * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:378

TAO_ClientRequestInfo_HepRep_getInstanceTreeTop::TAO_ClientRequestInfo_HepRep_getInstanceTreeTop (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * instanceTreeName,
    const char * instanceTreeVersion    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    instanceTreeName_ (instanceTreeName),
    instanceTreeVersion_ (instanceTreeVersion)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_HepRep_getInstanceTreeTop::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= instanceTreeName_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= instanceTreeVersion_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_HepRep_getInstanceTreeTop::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_HepRep_getInstanceTreeTop::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_HepRep_getInstanceTreeTop::result (::HepRepInstanceTree * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_HepRep_getTypeTree : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_HepRep_getTypeTree (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * typeTreeName,
      const char * typeTreeVersion);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (::HepRepTypeTree * result);
  
private:
  TAO_ClientRequestInfo_HepRep_getTypeTree (const TAO_ClientRequestInfo_HepRep_getTypeTree &);
  void operator= (const TAO_ClientRequestInfo_HepRep_getTypeTree &);
  const char * typeTreeName_;
  const char * typeTreeVersion_;
  
  ::HepRepTypeTree * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:378

TAO_ClientRequestInfo_HepRep_getTypeTree::TAO_ClientRequestInfo_HepRep_getTypeTree (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * typeTreeName,
    const char * typeTreeVersion    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    typeTreeName_ (typeTreeName),
    typeTreeVersion_ (typeTreeVersion)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_HepRep_getTypeTree::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= typeTreeName_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= typeTreeVersion_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_HepRep_getTypeTree::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_HepRep_getTypeTree::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_HepRep_getTypeTree::result (::HepRepTypeTree * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_HepRep_getInstances : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_HepRep_getInstances (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * instanceTreeName,
      const char * instanceTreeVersion,
      const StringArray & typeNames);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (::HepRepInstanceTree * result);
  
private:
  TAO_ClientRequestInfo_HepRep_getInstances (const TAO_ClientRequestInfo_HepRep_getInstances &);
  void operator= (const TAO_ClientRequestInfo_HepRep_getInstances &);
  const char * instanceTreeName_;
  const char * instanceTreeVersion_;
  const StringArray & typeNames_;
  
  ::HepRepInstanceTree * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:378

TAO_ClientRequestInfo_HepRep_getInstances::TAO_ClientRequestInfo_HepRep_getInstances (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * instanceTreeName,
    const char * instanceTreeVersion,
    const StringArray & typeNames    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    instanceTreeName_ (instanceTreeName),
    instanceTreeVersion_ (instanceTreeVersion),
    typeNames_ (typeNames)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_HepRep_getInstances::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (3);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= instanceTreeName_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= instanceTreeVersion_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->typeNames_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_HepRep_getInstances::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_HepRep_getInstances::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_HepRep_getInstances::result (::HepRepInstanceTree * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_HepRep_getInstancesAfterAction : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_HepRep_getInstancesAfterAction (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * instanceTreeName,
      const char * instanceTreeVersion,
      const StringArray & typeNames,
      const HepRepActionList & actions,
      const CORBA::Boolean & getPoints,
      const CORBA::Boolean & getDrawAtts,
      const CORBA::Boolean & getNonDrawAtts,
      const StringArray & invertAtts);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (::HepRepInstanceTree * result);
  
private:
  TAO_ClientRequestInfo_HepRep_getInstancesAfterAction (const TAO_ClientRequestInfo_HepRep_getInstancesAfterAction &);
  void operator= (const TAO_ClientRequestInfo_HepRep_getInstancesAfterAction &);
  const char * instanceTreeName_;
  const char * instanceTreeVersion_;
  const StringArray & typeNames_;
  const HepRepActionList & actions_;
  const CORBA::Boolean & getPoints_;
  const CORBA::Boolean & getDrawAtts_;
  const CORBA::Boolean & getNonDrawAtts_;
  const StringArray & invertAtts_;
  
  ::HepRepInstanceTree * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:378

TAO_ClientRequestInfo_HepRep_getInstancesAfterAction::TAO_ClientRequestInfo_HepRep_getInstancesAfterAction (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * instanceTreeName,
    const char * instanceTreeVersion,
    const StringArray & typeNames,
    const HepRepActionList & actions,
    const CORBA::Boolean & getPoints,
    const CORBA::Boolean & getDrawAtts,
    const CORBA::Boolean & getNonDrawAtts,
    const StringArray & invertAtts    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    instanceTreeName_ (instanceTreeName),
    instanceTreeVersion_ (instanceTreeVersion),
    typeNames_ (typeNames),
    actions_ (actions),
    getPoints_ (getPoints),
    getDrawAtts_ (getDrawAtts),
    getNonDrawAtts_ (getNonDrawAtts),
    invertAtts_ (invertAtts)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_HepRep_getInstancesAfterAction::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (8);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= instanceTreeName_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= instanceTreeVersion_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->typeNames_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->actions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->getPoints_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->getDrawAtts_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->getNonDrawAtts_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->invertAtts_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_HepRep_getInstancesAfterAction::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_HepRep_getInstancesAfterAction::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_HepRep_getInstancesAfterAction::result (::HepRepInstanceTree * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_HepRep_getLayerOrder : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_HepRep_getLayerOrder (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (::StringArray * result);
  
private:
  TAO_ClientRequestInfo_HepRep_getLayerOrder (const TAO_ClientRequestInfo_HepRep_getLayerOrder &);
  void operator= (const TAO_ClientRequestInfo_HepRep_getLayerOrder &);
  
  ::StringArray * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:378

TAO_ClientRequestInfo_HepRep_getLayerOrder::TAO_ClientRequestInfo_HepRep_getLayerOrder (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_HepRep_getLayerOrder::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_HepRep_getLayerOrder::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_HepRep_getLayerOrder::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_HepRep_getLayerOrder::result (::StringArray * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_HepRep_checkForException : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_HepRep_checkForException (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);
  
private:
  TAO_ClientRequestInfo_HepRep_checkForException (const TAO_ClientRequestInfo_HepRep_checkForException &);
  void operator= (const TAO_ClientRequestInfo_HepRep_checkForException &);
  
  char * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_cs.cpp:378

TAO_ClientRequestInfo_HepRep_checkForException::TAO_ClientRequestInfo_HepRep_checkForException (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_HepRep_checkForException::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_HepRep_checkForException::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_HepRep_checkForException::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_HepRep_checkForException::result (char * result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_HepRep_Proxy_Impl::_TAO_HepRep_Proxy_Impl (void)
{}

_TAO_HepRep_Remote_Proxy_Impl::_TAO_HepRep_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::HepRepInstanceTree * _TAO_HepRep_Remote_Proxy_Impl::getInstanceTreeTop (
    CORBA_Object *_collocated_tao_target_,
    const char * instanceTreeName,
    const char * instanceTreeVersion
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  HepRepInstanceTree_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    HepRepInstanceTree *tmp;
    ACE_NEW_RETURN (tmp, HepRepInstanceTree, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "getInstanceTreeTop",
      18,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_HepRep_getInstanceTreeTop _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          instanceTreeName,
          instanceTreeVersion
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << instanceTreeName) &&
              (_tao_out << instanceTreeVersion)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::HepRepInstanceTree * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::HepRepTypeTree * _TAO_HepRep_Remote_Proxy_Impl::getTypeTree (
    CORBA_Object *_collocated_tao_target_,
    const char * typeTreeName,
    const char * typeTreeVersion
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  HepRepTypeTree_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    HepRepTypeTree *tmp;
    ACE_NEW_RETURN (tmp, HepRepTypeTree, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "getTypeTree",
      11,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_HepRep_getTypeTree _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          typeTreeName,
          typeTreeVersion
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << typeTreeName) &&
              (_tao_out << typeTreeVersion)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::HepRepTypeTree * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::HepRepInstanceTree * _TAO_HepRep_Remote_Proxy_Impl::getInstances (
    CORBA_Object *_collocated_tao_target_,
    const char * instanceTreeName,
    const char * instanceTreeVersion,
    const StringArray & typeNames
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  HepRepInstanceTree_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    HepRepInstanceTree *tmp;
    ACE_NEW_RETURN (tmp, HepRepInstanceTree, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "getInstances",
      12,
      3,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_HepRep_getInstances _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          instanceTreeName,
          instanceTreeVersion,
          typeNames
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << instanceTreeName) &&
              (_tao_out << instanceTreeVersion) &&
              (_tao_out << typeNames)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::HepRepInstanceTree * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::HepRepInstanceTree * _TAO_HepRep_Remote_Proxy_Impl::getInstancesAfterAction (
    CORBA_Object *_collocated_tao_target_,
    const char * instanceTreeName,
    const char * instanceTreeVersion,
    const StringArray & typeNames,
    const HepRepActionList & actions,
    CORBA::Boolean getPoints,
    CORBA::Boolean getDrawAtts,
    CORBA::Boolean getNonDrawAtts,
    const StringArray & invertAtts
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  HepRepInstanceTree_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    HepRepInstanceTree *tmp;
    ACE_NEW_RETURN (tmp, HepRepInstanceTree, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "getInstancesAfterAction",
      23,
      8,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_HepRep_getInstancesAfterAction _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          instanceTreeName,
          instanceTreeVersion,
          typeNames,
          actions,
          getPoints,
          getDrawAtts,
          getNonDrawAtts,
          invertAtts
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << instanceTreeName) &&
              (_tao_out << instanceTreeVersion) &&
              (_tao_out << typeNames) &&
              (_tao_out << actions) &&
              (_tao_out << CORBA::Any::from_boolean (getPoints)) &&
              (_tao_out << CORBA::Any::from_boolean (getDrawAtts)) &&
              (_tao_out << CORBA::Any::from_boolean (getNonDrawAtts)) &&
              (_tao_out << invertAtts)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::HepRepInstanceTree * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::StringArray * _TAO_HepRep_Remote_Proxy_Impl::getLayerOrder (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  StringArray_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    StringArray *tmp;
    ACE_NEW_RETURN (tmp, StringArray, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "getLayerOrder",
      13,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_HepRep_getLayerOrder _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::StringArray * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

char * _TAO_HepRep_Remote_Proxy_Impl::checkForException (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  CORBA::String_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "checkForException",
      17,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_HepRep_checkForException _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          char * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_HepRep_Proxy_Broker::_TAO_HepRep_Proxy_Broker (void)
{
}

_TAO_HepRep_Proxy_Broker::~_TAO_HepRep_Proxy_Broker (void)
{
}

_TAO_HepRep_Proxy_Broker * (*_TAO_HepRep_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_HepRep_Remote_Proxy_Broker *
_TAO_HepRep_Remote_Proxy_Broker::the_TAO_HepRep_Remote_Proxy_Broker (void)
{
  static ::_TAO_HepRep_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_HepRep_Remote_Proxy_Broker::_TAO_HepRep_Remote_Proxy_Broker (void)
{
}

_TAO_HepRep_Remote_Proxy_Broker::~_TAO_HepRep_Remote_Proxy_Broker (void)
{
}

_TAO_HepRep_Proxy_Impl&
_TAO_HepRep_Remote_Proxy_Broker::select_proxy (
    ::HepRep *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:225

HepRep::HepRep (int collocated)
{
  this->HepRep_setup_collocation (collocated);
}

void
HepRep::HepRep_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_HepRep_Proxy_Broker_ =
      ::_TAO_HepRep_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_HepRep_Proxy_Broker_ =
      ::_TAO_HepRep_Remote_Proxy_Broker::the_TAO_HepRep_Remote_Proxy_Broker ();
}

HepRep::~HepRep (void)
{}

void 
HepRep::_tao_any_destructor (void *_tao_void_pointer)
{
  HepRep *tmp = ACE_static_cast (HepRep *, _tao_void_pointer);
  CORBA::release (tmp);
}

HepRep_ptr
HepRep::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return HepRep::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:HepRep:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (HepRep::_nil ());
      
      if (is_a == 0)
        {
          return HepRep::_nil ();
        }
    }
  
  return HepRep::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

HepRep_ptr 
HepRep::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return HepRep::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      HepRep_ptr default_proxy = HepRep::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          _TAO_HepRep_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::HepRep (
                  stub,
                  1,
                  obj->_servant ()
                ),
              HepRep::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::HepRep (
                  stub,
                  0,
                  obj->_servant ()
                ),
              HepRep::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          HepRep_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &HepRep::_tao_class_id
                )
            )
        );
}

HepRep_ptr
HepRep::_duplicate (HepRep_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
HepRep::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:HepRep:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *HepRep::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &HepRep::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* HepRep::_interface_repository_id (void) const
{
  return "IDL:HepRep:1.0";
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::HepRepInstanceTree * HepRep::getInstanceTreeTop (
    const char * instanceTreeName,
    const char * instanceTreeVersion
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HepRep_Proxy_Impl &proxy = 
    this->the_TAO_HepRep_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.getInstanceTreeTop (
      this,
      instanceTreeName,
      instanceTreeVersion
    );
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::HepRepTypeTree * HepRep::getTypeTree (
    const char * typeTreeName,
    const char * typeTreeVersion
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HepRep_Proxy_Impl &proxy = 
    this->the_TAO_HepRep_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.getTypeTree (
      this,
      typeTreeName,
      typeTreeVersion
    );
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::HepRepInstanceTree * HepRep::getInstances (
    const char * instanceTreeName,
    const char * instanceTreeVersion,
    const StringArray & typeNames
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HepRep_Proxy_Impl &proxy = 
    this->the_TAO_HepRep_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.getInstances (
      this,
      instanceTreeName,
      instanceTreeVersion,
      typeNames
    );
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::HepRepInstanceTree * HepRep::getInstancesAfterAction (
    const char * instanceTreeName,
    const char * instanceTreeVersion,
    const StringArray & typeNames,
    const HepRepActionList & actions,
    CORBA::Boolean getPoints,
    CORBA::Boolean getDrawAtts,
    CORBA::Boolean getNonDrawAtts,
    const StringArray & invertAtts
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HepRep_Proxy_Impl &proxy = 
    this->the_TAO_HepRep_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.getInstancesAfterAction (
      this,
      instanceTreeName,
      instanceTreeVersion,
      typeNames,
      actions,
      getPoints,
      getDrawAtts,
      getNonDrawAtts,
      invertAtts
    );
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

::StringArray * HepRep::getLayerOrder (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HepRep_Proxy_Impl &proxy = 
    this->the_TAO_HepRep_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.getLayerOrder (
      this
    );
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:80

char * HepRep::checkForException (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HepRep_Proxy_Impl &proxy = 
    this->the_TAO_HepRep_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.checkForException (
      this
    );
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_HepRep[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  15,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65703a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:HepRep:1.0
  7,
  ACE_NTOHL (0x48657052), 
  ACE_NTOHL (0x65700000),  // name = HepRep
};

static CORBA::TypeCode _tc_TAO_tc_HepRep (
    CORBA::tk_objref,
    sizeof (_oc_HepRep),
    (char *) &_oc_HepRep,
    0,
    sizeof (HepRep)
  );

::CORBA::TypeCode_ptr _tc_HepRep =
  &_tc_TAO_tc_HepRep;

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const StringArray &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_StringArray,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    StringArray *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_StringArray,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          StringArray::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    StringArray *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const StringArray*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const StringArray *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_StringArray
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const StringArray*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        StringArray *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            StringArray,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_StringArray,
                1,
                ACE_static_cast (void *, tmp),
                StringArray::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepAttDef &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepAttDef,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepAttDef *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepAttDef,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepAttDef::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepAttDef *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const HepRepAttDef *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepAttDef *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepAttDef
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const HepRepAttDef*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepAttDef *tmp;
        ACE_NEW_RETURN (
            tmp,
            HepRepAttDef,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepAttDef,
                1,
                ACE_static_cast (void *, tmp),
                HepRepAttDef::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepAttDefList &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepAttDefList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepAttDefList *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepAttDefList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepAttDefList::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepAttDefList *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const HepRepAttDefList*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepAttDefList *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepAttDefList
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const HepRepAttDefList*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepAttDefList *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            HepRepAttDefList,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepAttDefList,
                1,
                ACE_static_cast (void *, tmp),
                HepRepAttDefList::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepAttValue &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepAttValue,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepAttValue *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepAttValue,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepAttValue::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepAttValue *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const HepRepAttValue *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepAttValue *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepAttValue
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const HepRepAttValue*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepAttValue *tmp;
        ACE_NEW_RETURN (
            tmp,
            HepRepAttValue,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepAttValue,
                1,
                ACE_static_cast (void *, tmp),
                HepRepAttValue::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepAttValueList &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepAttValueList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepAttValueList *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepAttValueList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepAttValueList::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepAttValueList *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const HepRepAttValueList*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepAttValueList *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepAttValueList
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const HepRepAttValueList*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepAttValueList *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            HepRepAttValueList,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepAttValueList,
                1,
                ACE_static_cast (void *, tmp),
                HepRepAttValueList::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepPoint &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepPoint,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepPoint *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepPoint,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepPoint::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepPoint *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const HepRepPoint *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepPoint *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepPoint
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const HepRepPoint*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepPoint *tmp;
        ACE_NEW_RETURN (
            tmp,
            HepRepPoint,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepPoint,
                1,
                ACE_static_cast (void *, tmp),
                HepRepPoint::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepPointList &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepPointList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepPointList *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepPointList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepPointList::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepPointList *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const HepRepPointList*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepPointList *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepPointList
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const HepRepPointList*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepPointList *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            HepRepPointList,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepPointList,
                1,
                ACE_static_cast (void *, tmp),
                HepRepPointList::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepInstance &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepInstance,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepInstance *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepInstance,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepInstance::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepInstance *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const HepRepInstance *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepInstance *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepInstance
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const HepRepInstance*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepInstance *tmp;
        ACE_NEW_RETURN (
            tmp,
            HepRepInstance,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepInstance,
                1,
                ACE_static_cast (void *, tmp),
                HepRepInstance::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepInstanceList &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepInstanceList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepInstanceList *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepInstanceList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepInstanceList::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepInstanceList *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const HepRepInstanceList*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepInstanceList *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepInstanceList
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const HepRepInstanceList*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepInstanceList *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            HepRepInstanceList,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepInstanceList,
                1,
                ACE_static_cast (void *, tmp),
                HepRepInstanceList::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepTreeID &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepTreeID,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepTreeID *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepTreeID,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepTreeID::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepTreeID *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const HepRepTreeID *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepTreeID *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepTreeID
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const HepRepTreeID*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepTreeID *tmp;
        ACE_NEW_RETURN (
            tmp,
            HepRepTreeID,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepTreeID,
                1,
                ACE_static_cast (void *, tmp),
                HepRepTreeID::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepTreeIDList &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepTreeIDList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepTreeIDList *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepTreeIDList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepTreeIDList::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepTreeIDList *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const HepRepTreeIDList*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepTreeIDList *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepTreeIDList
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const HepRepTreeIDList*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepTreeIDList *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            HepRepTreeIDList,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepTreeIDList,
                1,
                ACE_static_cast (void *, tmp),
                HepRepTreeIDList::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepInstanceTree &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepInstanceTree,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepInstanceTree *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepInstanceTree,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepInstanceTree::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepInstanceTree *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const HepRepInstanceTree *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepInstanceTree *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepInstanceTree
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const HepRepInstanceTree*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepInstanceTree *tmp;
        ACE_NEW_RETURN (
            tmp,
            HepRepInstanceTree,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepInstanceTree,
                1,
                ACE_static_cast (void *, tmp),
                HepRepInstanceTree::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepType &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepType,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepType *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepType,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepType::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepType *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const HepRepType *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepType *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepType
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const HepRepType*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepType *tmp;
        ACE_NEW_RETURN (
            tmp,
            HepRepType,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepType,
                1,
                ACE_static_cast (void *, tmp),
                HepRepType::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepTypeList &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepTypeList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepTypeList *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepTypeList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepTypeList::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepTypeList *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const HepRepTypeList*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepTypeList *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepTypeList
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const HepRepTypeList*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepTypeList *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            HepRepTypeList,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepTypeList,
                1,
                ACE_static_cast (void *, tmp),
                HepRepTypeList::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepTypeTree &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepTypeTree,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepTypeTree *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepTypeTree,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepTypeTree::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepTypeTree *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const HepRepTypeTree *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepTypeTree *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepTypeTree
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const HepRepTypeTree*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepTypeTree *tmp;
        ACE_NEW_RETURN (
            tmp,
            HepRepTypeTree,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepTypeTree,
                1,
                ACE_static_cast (void *, tmp),
                HepRepTypeTree::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepAction &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepAction,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepAction *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepAction,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepAction::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepAction *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const HepRepAction *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepAction *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepAction
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const HepRepAction*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepAction *tmp;
        ACE_NEW_RETURN (
            tmp,
            HepRepAction,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepAction,
                1,
                ACE_static_cast (void *, tmp),
                HepRepAction::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const HepRepActionList &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepActionList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    HepRepActionList *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRepActionList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          HepRepActionList::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    HepRepActionList *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const HepRepActionList*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const HepRepActionList *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRepActionList
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const HepRepActionList*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        HepRepActionList *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            HepRepActionList,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                _tc_HepRepActionList,
                1,
                ACE_static_cast (void *, tmp),
                HepRepActionList::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    HepRep_ptr _tao_elem
  )
{
  HepRep_ptr _tao_objptr =
    HepRep::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    HepRep_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          _tc_HepRep, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          HepRep::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    HepRep_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = HepRep::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          _tc_HepRep
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            _tc_HepRep,
            1,
            _tao_elem,
            HepRep::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = HepRep::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = HepRep::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<HepRep,HepRep_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<HepRep,HepRep_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const StringArray &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    StringArray &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepAttDefList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepAttDefList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepAttValueList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepAttValueList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepPointList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepPointList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:103

#if !defined _TAO_CDR_OP_HepRepInstance__tao_seq_HepRepInstance_CPP_
#define _TAO_CDR_OP_HepRepInstance__tao_seq_HepRepInstance_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepInstance::_tao_seq_HepRepInstance &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepInstance::_tao_seq_HepRepInstance &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_HepRepInstance__tao_seq_HepRepInstance_CPP_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepInstanceList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepInstanceList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepTreeIDList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepTreeIDList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:103

#if !defined _TAO_CDR_OP_HepRepType__tao_seq_HepRepType_CPP_
#define _TAO_CDR_OP_HepRepType__tao_seq_HepRepType_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepType::_tao_seq_HepRepType &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepType::_tao_seq_HepRepType &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_HepRepType__tao_seq_HepRepType_CPP_ */

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepTypeList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepTypeList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRepActionList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRepActionList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const HepRep_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    HepRep_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      HepRep::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

