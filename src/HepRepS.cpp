// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from 
// be\be_codegen.cpp:677

#ifndef _TAO_IDL_HEPREPS_CPP_
#define _TAO_IDL_HEPREPS_CPP_


#include "HepRepS.h"
#include "tao/PortableServer/Object_Adapter.h"
#include "tao/PortableServer/Operation_Table.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/PortableInterceptor.h"
#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/PICurrent.h"
#include "tao/PortableServer/ServerRequestInfo.h"
#include "tao/PortableServer/ServerInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#include "ace/Dynamic_Service.h"

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "HepRepS.i"
#endif /* !defined INLINE */



// TAO_IDL - Generated from
// be\be_interface.cpp:1726

class TAO_HepRep_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_HepRep_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_HepRep_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29,  0,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29,  0,
     29,  0, 29,  5, 29,  0, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29,  0,
     29,  0, 29, 15, 29, 29, 29, 29, 29, 29,
     29, 29,  0,  0, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29,
#else
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29,  0, 29,  0, 29,  0,
     29,  5, 29,  0, 29, 29, 29, 29, 29, 29,
      0, 29,  0, 29, 15,  0,  0, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_HepRep_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 23,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 28,
      HASH_VALUE_RANGE = 24,
      DUPLICATES = 0,
      WORDLIST_SIZE = 15
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_HepRep::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_component",  &POA_HepRep::_component_skel},
      {"",0},
      {"getInstances", 	&POA_HepRep::getInstances_skel},
      {"_non_existent",  &POA_HepRep::_non_existent_skel},
      {"",0},
      {"_interface",  &POA_HepRep::_interface_skel},
      {"getTypeTree", 	&POA_HepRep::getTypeTree_skel},
      {"checkForException", 	&POA_HepRep::checkForException_skel},
      {"getInstanceTreeTop", 	&POA_HepRep::getInstanceTreeTop_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"getInstancesAfterAction", 	&POA_HepRep::getInstancesAfterAction_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"getLayerOrder", 	&POA_HepRep::getLayerOrder_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
static TAO_HepRep_Perfect_Hash_OpTable tao_HepRep_optable;

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interceptors_ss.cpp:52

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:74

class TAO_ServerRequestInfo_HepRep_getInstanceTreeTop : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_HepRep_getInstanceTreeTop (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,
      POA_HepRep *tao_impl,
      const char * instanceTreeName,
      const char * instanceTreeVersion
    );
  
  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  void result (::HepRepInstanceTree * result);

private:
  TAO_ServerRequestInfo_HepRep_getInstanceTreeTop (
      const TAO_ServerRequestInfo_HepRep_getInstanceTreeTop &
    );
  
  void operator= (
      const TAO_ServerRequestInfo_HepRep_getInstanceTreeTop &
    );
  
private:
  POA_HepRep *_tao_impl;
  
  const char * instanceTreeName_;
  const char * instanceTreeVersion_;::HepRepInstanceTree * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:438

TAO_ServerRequestInfo_HepRep_getInstanceTreeTop::TAO_ServerRequestInfo_HepRep_getInstanceTreeTop (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_HepRep *tao_impl,
    const char * instanceTreeName,
    const char * instanceTreeVersion
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    instanceTreeName_ (instanceTreeName),
    instanceTreeVersion_ (instanceTreeVersion)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_HepRep_getInstanceTreeTop::arguments (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  parameter_list->length (2);
  CORBA::ULong len = 0;
  
  (*parameter_list)[len].argument <<= instanceTreeName_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= instanceTreeVersion_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_HepRep_getInstanceTreeTop::exceptions (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_HepRep_getInstanceTreeTop::result (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_HepRep_getInstanceTreeTop::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_HepRep_getInstanceTreeTop::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_HepRep_getInstanceTreeTop::result (::HepRepInstanceTree * result)
{
  // Update the result.
   this->_result = result;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:74

class TAO_ServerRequestInfo_HepRep_getTypeTree : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_HepRep_getTypeTree (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,
      POA_HepRep *tao_impl,
      const char * typeTreeName,
      const char * typeTreeVersion
    );
  
  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  void result (::HepRepTypeTree * result);

private:
  TAO_ServerRequestInfo_HepRep_getTypeTree (
      const TAO_ServerRequestInfo_HepRep_getTypeTree &
    );
  
  void operator= (
      const TAO_ServerRequestInfo_HepRep_getTypeTree &
    );
  
private:
  POA_HepRep *_tao_impl;
  
  const char * typeTreeName_;
  const char * typeTreeVersion_;::HepRepTypeTree * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:438

TAO_ServerRequestInfo_HepRep_getTypeTree::TAO_ServerRequestInfo_HepRep_getTypeTree (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_HepRep *tao_impl,
    const char * typeTreeName,
    const char * typeTreeVersion
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    typeTreeName_ (typeTreeName),
    typeTreeVersion_ (typeTreeVersion)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_HepRep_getTypeTree::arguments (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  parameter_list->length (2);
  CORBA::ULong len = 0;
  
  (*parameter_list)[len].argument <<= typeTreeName_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= typeTreeVersion_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_HepRep_getTypeTree::exceptions (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_HepRep_getTypeTree::result (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_HepRep_getTypeTree::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_HepRep_getTypeTree::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_HepRep_getTypeTree::result (::HepRepTypeTree * result)
{
  // Update the result.
   this->_result = result;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:74

class TAO_ServerRequestInfo_HepRep_getInstances : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_HepRep_getInstances (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,
      POA_HepRep *tao_impl,
      const char * instanceTreeName,
      const char * instanceTreeVersion,
      const StringArray & typeNames
    );
  
  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  void result (::HepRepInstanceTree * result);

private:
  TAO_ServerRequestInfo_HepRep_getInstances (
      const TAO_ServerRequestInfo_HepRep_getInstances &
    );
  
  void operator= (
      const TAO_ServerRequestInfo_HepRep_getInstances &
    );
  
private:
  POA_HepRep *_tao_impl;
  
  const char * instanceTreeName_;
  const char * instanceTreeVersion_;
  const StringArray & typeNames_;::HepRepInstanceTree * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:438

TAO_ServerRequestInfo_HepRep_getInstances::TAO_ServerRequestInfo_HepRep_getInstances (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_HepRep *tao_impl,
    const char * instanceTreeName,
    const char * instanceTreeVersion,
    const StringArray & typeNames
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    instanceTreeName_ (instanceTreeName),
    instanceTreeVersion_ (instanceTreeVersion),
    typeNames_ (typeNames)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_HepRep_getInstances::arguments (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  parameter_list->length (3);
  CORBA::ULong len = 0;
  
  (*parameter_list)[len].argument <<= instanceTreeName_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= instanceTreeVersion_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->typeNames_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_HepRep_getInstances::exceptions (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_HepRep_getInstances::result (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_HepRep_getInstances::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_HepRep_getInstances::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_HepRep_getInstances::result (::HepRepInstanceTree * result)
{
  // Update the result.
   this->_result = result;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:74

class TAO_ServerRequestInfo_HepRep_getInstancesAfterAction : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_HepRep_getInstancesAfterAction (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,
      POA_HepRep *tao_impl,
      const char * instanceTreeName,
      const char * instanceTreeVersion,
      const StringArray & typeNames,
      const HepRepActionList & actions,
      const CORBA::Boolean & getPoints,
      const CORBA::Boolean & getDrawAtts,
      const CORBA::Boolean & getNonDrawAtts,
      const StringArray & invertAtts
    );
  
  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  void result (::HepRepInstanceTree * result);

private:
  TAO_ServerRequestInfo_HepRep_getInstancesAfterAction (
      const TAO_ServerRequestInfo_HepRep_getInstancesAfterAction &
    );
  
  void operator= (
      const TAO_ServerRequestInfo_HepRep_getInstancesAfterAction &
    );
  
private:
  POA_HepRep *_tao_impl;
  
  const char * instanceTreeName_;
  const char * instanceTreeVersion_;
  const StringArray & typeNames_;
  const HepRepActionList & actions_;
  const CORBA::Boolean & getPoints_;
  const CORBA::Boolean & getDrawAtts_;
  const CORBA::Boolean & getNonDrawAtts_;
  const StringArray & invertAtts_;::HepRepInstanceTree * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:438

TAO_ServerRequestInfo_HepRep_getInstancesAfterAction::TAO_ServerRequestInfo_HepRep_getInstancesAfterAction (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_HepRep *tao_impl,
    const char * instanceTreeName,
    const char * instanceTreeVersion,
    const StringArray & typeNames,
    const HepRepActionList & actions,
    const CORBA::Boolean & getPoints,
    const CORBA::Boolean & getDrawAtts,
    const CORBA::Boolean & getNonDrawAtts,
    const StringArray & invertAtts
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    instanceTreeName_ (instanceTreeName),
    instanceTreeVersion_ (instanceTreeVersion),
    typeNames_ (typeNames),
    actions_ (actions),
    getPoints_ (getPoints),
    getDrawAtts_ (getDrawAtts),
    getNonDrawAtts_ (getNonDrawAtts),
    invertAtts_ (invertAtts)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_HepRep_getInstancesAfterAction::arguments (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  parameter_list->length (8);
  CORBA::ULong len = 0;
  
  (*parameter_list)[len].argument <<= instanceTreeName_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= instanceTreeVersion_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->typeNames_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->actions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->getPoints_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->getDrawAtts_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->getNonDrawAtts_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->invertAtts_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_HepRep_getInstancesAfterAction::exceptions (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_HepRep_getInstancesAfterAction::result (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_HepRep_getInstancesAfterAction::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_HepRep_getInstancesAfterAction::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_HepRep_getInstancesAfterAction::result (::HepRepInstanceTree * result)
{
  // Update the result.
   this->_result = result;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:74

class TAO_ServerRequestInfo_HepRep_getLayerOrder : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_HepRep_getLayerOrder (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,
      POA_HepRep *tao_impl
    );
  
  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  void result (::StringArray * result);

private:
  TAO_ServerRequestInfo_HepRep_getLayerOrder (
      const TAO_ServerRequestInfo_HepRep_getLayerOrder &
    );
  
  void operator= (
      const TAO_ServerRequestInfo_HepRep_getLayerOrder &
    );
  
private:
  POA_HepRep *_tao_impl;
  ::StringArray * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:438

TAO_ServerRequestInfo_HepRep_getLayerOrder::TAO_ServerRequestInfo_HepRep_getLayerOrder (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_HepRep *tao_impl
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_HepRep_getLayerOrder::arguments (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_HepRep_getLayerOrder::exceptions (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_HepRep_getLayerOrder::result (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_HepRep_getLayerOrder::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_HepRep_getLayerOrder::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_HepRep_getLayerOrder::result (::StringArray * result)
{
  // Update the result.
   this->_result = result;
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:74

class TAO_ServerRequestInfo_HepRep_checkForException : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_HepRep_checkForException (
      TAO_ServerRequest &_tao_server_request,
      TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,
      POA_HepRep *tao_impl
    );
  
  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  void result (char * result);

private:
  TAO_ServerRequestInfo_HepRep_checkForException (
      const TAO_ServerRequestInfo_HepRep_checkForException &
    );
  
  void operator= (
      const TAO_ServerRequestInfo_HepRep_checkForException &
    );
  
private:
  POA_HepRep *_tao_impl;
  char * _result;
};

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/interceptors_ss.cpp:438

TAO_ServerRequestInfo_HepRep_checkForException::TAO_ServerRequestInfo_HepRep_checkForException (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_HepRep *tao_impl
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_HepRep_checkForException::arguments (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_HepRep_checkForException::exceptions (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_HepRep_checkForException::result (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_HepRep_checkForException::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_HepRep_checkForException::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_HepRep_checkForException::result (char * result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
_TAO_HepRep_Strategized_Proxy_Broker *_TAO_HepRep_Strategized_Proxy_Broker::the_TAO_HepRep_Strategized_Proxy_Broker (void)
{
  static _TAO_HepRep_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_HepRep_Strategized_Proxy_Broker::_TAO_HepRep_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      this->proxy_cache_[i] = 0;
    }
}

_TAO_HepRep_Strategized_Proxy_Broker::~_TAO_HepRep_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    {
      delete this->proxy_cache_[i];
      
      // Hack to prevent bug mentioned in 1204. Refer to 1204
      // for details..
      this->proxy_cache_[i] = 0;
    }
}

_TAO_HepRep_Proxy_Impl&
_TAO_HepRep_Strategized_Proxy_Broker::select_proxy (
    ::HepRep *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    {
      return *this->proxy_cache_[strategy];
    }
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
}

void 
_TAO_HepRep_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_HepRep_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_HepRep_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        }
    }
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:598

_TAO_HepRep_Proxy_Broker *
_TAO_HepRep_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_HepRep_Strategized_Proxy_Broker::the_TAO_HepRep_Strategized_Proxy_Broker();
}

int
_TAO_HepRep_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_HepRep_Proxy_Broker_Factory_function_pointer = 
    _TAO_HepRep_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_HepRep_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_HepRep_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_HepRep_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/thru_poa_proxy_impl_ss.cpp:37

_TAO_HepRep_ThruPOA_Proxy_Impl::_TAO_HepRep_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/thru_poa_proxy_impl_ss.cpp:67

::HepRepInstanceTree * _TAO_HepRep_ThruPOA_Proxy_Impl::getInstanceTreeTop (
    CORBA_Object *_collocated_tao_target_,
    const char * instanceTreeName,
    const char * instanceTreeVersion
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "getInstanceTreeTop",
      forward_to.out ()
    );
  
  servant_upcall.pre_invoke_collocated_request ();
  
  return ACE_reinterpret_cast (
      POA_HepRep_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:HepRep:1.0"
        )
    )->getInstanceTreeTop (
        
        instanceTreeName,
        instanceTreeVersion
      );
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/thru_poa_proxy_impl_ss.cpp:67

::HepRepTypeTree * _TAO_HepRep_ThruPOA_Proxy_Impl::getTypeTree (
    CORBA_Object *_collocated_tao_target_,
    const char * typeTreeName,
    const char * typeTreeVersion
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "getTypeTree",
      forward_to.out ()
    );
  
  servant_upcall.pre_invoke_collocated_request ();
  
  return ACE_reinterpret_cast (
      POA_HepRep_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:HepRep:1.0"
        )
    )->getTypeTree (
        
        typeTreeName,
        typeTreeVersion
      );
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/thru_poa_proxy_impl_ss.cpp:67

::HepRepInstanceTree * _TAO_HepRep_ThruPOA_Proxy_Impl::getInstances (
    CORBA_Object *_collocated_tao_target_,
    const char * instanceTreeName,
    const char * instanceTreeVersion,
    const StringArray & typeNames
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "getInstances",
      forward_to.out ()
    );
  
  servant_upcall.pre_invoke_collocated_request ();
  
  return ACE_reinterpret_cast (
      POA_HepRep_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:HepRep:1.0"
        )
    )->getInstances (
        
        instanceTreeName,
        instanceTreeVersion,
        typeNames
      );
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/thru_poa_proxy_impl_ss.cpp:67

::HepRepInstanceTree * _TAO_HepRep_ThruPOA_Proxy_Impl::getInstancesAfterAction (
    CORBA_Object *_collocated_tao_target_,
    const char * instanceTreeName,
    const char * instanceTreeVersion,
    const StringArray & typeNames,
    const HepRepActionList & actions,
    CORBA::Boolean getPoints,
    CORBA::Boolean getDrawAtts,
    CORBA::Boolean getNonDrawAtts,
    const StringArray & invertAtts
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "getInstancesAfterAction",
      forward_to.out ()
    );
  
  servant_upcall.pre_invoke_collocated_request ();
  
  return ACE_reinterpret_cast (
      POA_HepRep_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:HepRep:1.0"
        )
    )->getInstancesAfterAction (
        
        instanceTreeName,
        instanceTreeVersion,
        typeNames,
        actions,
        getPoints,
        getDrawAtts,
        getNonDrawAtts,
        invertAtts
      );
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/thru_poa_proxy_impl_ss.cpp:67

::StringArray * _TAO_HepRep_ThruPOA_Proxy_Impl::getLayerOrder (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "getLayerOrder",
      forward_to.out ()
    );
  
  servant_upcall.pre_invoke_collocated_request ();
  
  return ACE_reinterpret_cast (
      POA_HepRep_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:HepRep:1.0"
        )
    )->getLayerOrder (
        
      );
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/thru_poa_proxy_impl_ss.cpp:67

char * _TAO_HepRep_ThruPOA_Proxy_Impl::checkForException (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "checkForException",
      forward_to.out ()
    );
  
  servant_upcall.pre_invoke_collocated_request ();
  
  return ACE_reinterpret_cast (
      POA_HepRep_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:HepRep:1.0"
        )
    )->checkForException (
        
      );
}//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:98

POA_HepRep::POA_HepRep (void)
{
  this->optable_ = &tao_HepRep_optable;
}

POA_HepRep::POA_HepRep (const POA_HepRep& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_HepRep::~POA_HepRep (void)
{
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:100

void POA_HepRep::getInstanceTreeTop_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_HepRep *_tao_impl =
    ACE_static_cast (
        POA_HepRep *,
        _tao_servant
      );
  ::HepRepInstanceTree_var _tao_retval;
  CORBA::String_var instanceTreeName;
  CORBA::String_var instanceTreeVersion;
  
  if (!(
      (_tao_in >> instanceTreeName.out ()) &&
      (_tao_in >> instanceTreeVersion.out ())
    ))
    ACE_THROW (CORBA::MARSHAL ());

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_HepRep_getInstanceTreeTop _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      
      instanceTreeName.in (),
      
      instanceTreeVersion.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->getInstanceTreeTop (
                
                instanceTreeName.in (),
                
                instanceTreeVersion.in ()
              );
            

#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::HepRepInstanceTree * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        {
          ACE_RE_THROW;
        }
    }
  
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
  ACE_CATCHALL
    {
      CORBA::UNKNOWN ex;
      
      _tao_ri.exception (&ex);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
        ACE_TRY_THROW (ex);
    }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
  
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL ());
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:100

void POA_HepRep::getTypeTree_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_HepRep *_tao_impl =
    ACE_static_cast (
        POA_HepRep *,
        _tao_servant
      );
  ::HepRepTypeTree_var _tao_retval;
  CORBA::String_var typeTreeName;
  CORBA::String_var typeTreeVersion;
  
  if (!(
      (_tao_in >> typeTreeName.out ()) &&
      (_tao_in >> typeTreeVersion.out ())
    ))
    ACE_THROW (CORBA::MARSHAL ());

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_HepRep_getTypeTree _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      
      typeTreeName.in (),
      
      typeTreeVersion.in ()
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->getTypeTree (
                
                typeTreeName.in (),
                
                typeTreeVersion.in ()
              );
            

#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::HepRepTypeTree * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        {
          ACE_RE_THROW;
        }
    }
  
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
  ACE_CATCHALL
    {
      CORBA::UNKNOWN ex;
      
      _tao_ri.exception (&ex);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
        ACE_TRY_THROW (ex);
    }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
  
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL ());
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:100

void POA_HepRep::getInstances_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_HepRep *_tao_impl =
    ACE_static_cast (
        POA_HepRep *,
        _tao_servant
      );
  ::HepRepInstanceTree_var _tao_retval;
  CORBA::String_var instanceTreeName;
  CORBA::String_var instanceTreeVersion;
  StringArray typeNames;
  
  if (!(
      (_tao_in >> instanceTreeName.out ()) &&
      (_tao_in >> instanceTreeVersion.out ()) &&
      (_tao_in >> typeNames)
    ))
    ACE_THROW (CORBA::MARSHAL ());

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_HepRep_getInstances _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      
      instanceTreeName.in (),
      
      instanceTreeVersion.in (),
      
      typeNames
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->getInstances (
                
                instanceTreeName.in (),
                
                instanceTreeVersion.in (),
                
                typeNames
              );
            

#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::HepRepInstanceTree * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        {
          ACE_RE_THROW;
        }
    }
  
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
  ACE_CATCHALL
    {
      CORBA::UNKNOWN ex;
      
      _tao_ri.exception (&ex);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
        ACE_TRY_THROW (ex);
    }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
  
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL ());
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:100

void POA_HepRep::getInstancesAfterAction_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_HepRep *_tao_impl =
    ACE_static_cast (
        POA_HepRep *,
        _tao_servant
      );
  ::HepRepInstanceTree_var _tao_retval;
  CORBA::String_var instanceTreeName;
  CORBA::String_var instanceTreeVersion;
  StringArray typeNames;
  HepRepActionList actions;
  CORBA::Boolean getPoints;
  CORBA::Boolean getDrawAtts;
  CORBA::Boolean getNonDrawAtts;
  StringArray invertAtts;
  
  if (!(
      (_tao_in >> instanceTreeName.out ()) &&
      (_tao_in >> instanceTreeVersion.out ()) &&
      (_tao_in >> typeNames) &&
      (_tao_in >> actions) &&
      (_tao_in >> CORBA::Any::to_boolean (getPoints)) &&
      (_tao_in >> CORBA::Any::to_boolean (getDrawAtts)) &&
      (_tao_in >> CORBA::Any::to_boolean (getNonDrawAtts)) &&
      (_tao_in >> invertAtts)
    ))
    ACE_THROW (CORBA::MARSHAL ());

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_HepRep_getInstancesAfterAction _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      
      instanceTreeName.in (),
      
      instanceTreeVersion.in (),
      
      typeNames,
      
      actions,
      
      getPoints,
      
      getDrawAtts,
      
      getNonDrawAtts,
      
      invertAtts
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->getInstancesAfterAction (
                
                instanceTreeName.in (),
                
                instanceTreeVersion.in (),
                
                typeNames,
                
                actions,
                
                getPoints,
                
                getDrawAtts,
                
                getNonDrawAtts,
                
                invertAtts
              );
            

#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::HepRepInstanceTree * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        {
          ACE_RE_THROW;
        }
    }
  
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
  ACE_CATCHALL
    {
      CORBA::UNKNOWN ex;
      
      _tao_ri.exception (&ex);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
        ACE_TRY_THROW (ex);
    }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
  
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL ());
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:100

void POA_HepRep::getLayerOrder_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_HepRep *_tao_impl =
    ACE_static_cast (
        POA_HepRep *,
        _tao_servant
      );
  ::StringArray_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_HepRep_getLayerOrder _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->getLayerOrder (
                
              );
            

#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          ::StringArray * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        {
          ACE_RE_THROW;
        }
    }
  
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
  ACE_CATCHALL
    {
      CORBA::UNKNOWN ex;
      
      _tao_ri.exception (&ex);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
        ACE_TRY_THROW (ex);
    }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
  
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL ());
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:100

void POA_HepRep::checkForException_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_servant,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_HepRep *_tao_impl =
    ACE_static_cast (
        POA_HepRep *,
        _tao_servant
      );
  CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_HepRep_checkForException _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (!_tao_vfr.location_forwarded ())
          {
            
#endif /* TAO_HAS_INTERCEPTORS */
            _tao_retval = 
            _tao_impl->checkForException (
                
              );
            

#if (TAO_HAS_INTERCEPTORS == 1)
            
          }
      }
      
      if (!_tao_vfr.location_forwarded ())
        {
          char * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
          _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
          ACE_TRY_CHECK;
        }
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        {
          ACE_RE_THROW;
        }
    }
  
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
  ACE_CATCHALL
    {
      CORBA::UNKNOWN ex;
      
      _tao_ri.exception (&ex);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
        ACE_TRY_THROW (ex);
    }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
  
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL ());
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

// TAO_IDL - Generated from 
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:163

void POA_HepRep::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_HepRep *_tao_impl = (POA_HepRep *) _tao_servant;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_HepRep::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_HepRep *_tao_impl = (POA_HepRep *) _tao_servant;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_HepRep::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_servant,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_HepRep *_tao_impl = (POA_HepRep *) _tao_servant;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_HepRep::_component_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_HepRep *_tao_impl = (POA_HepRep *) _tao_object_reference;
  CORBA::Object_var _tao_retval =
    _tao_impl->_get_component (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(_tao_out << _tao_retval._retn ()))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_HepRep::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:HepRep:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:org.omg/CORBA/Object:1.0"
        )
     )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

void* POA_HepRep::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id,
                      "IDL:HepRep:1.0") == 0)
    {
      return ACE_static_cast (POA_HepRep_ptr, this);
    }
  
  if (ACE_OS::strcmp (logical_type_id,
                      "IDL:omg.org/CORBA/Object:1.0") == 0)
    {
      return ACE_static_cast(PortableServer::Servant, this);
    }
  
  return 0;
}

const char* POA_HepRep::_interface_repository_id (void) const
{
  return "IDL:HepRep:1.0";
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:532

void POA_HepRep::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// e:\ric\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:478

HepRep *
POA_HepRep::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    {
      ACE_NEW_RETURN (
          tmp,
          CORBA::Object (
              stub,
              1,
              this
            ),
          0
        );
    }
  else
    {
      ACE_NEW_RETURN (
          tmp,
          CORBA::Object (
              stub,
              0,
              this
            ),
          0
        );
    }
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  return ::HepRep::_unchecked_narrow (obj.in ());
}
#endif /* ifndef */
