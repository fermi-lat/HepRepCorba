// This file is generated by omniidl (C++ backend)- omniORB_4_0. Do not edit.
#ifndef __HepRep_hh__
#define __HepRep_hh__

#ifndef USE_omniORB_logStream
#define USE_omniORB_logStream
#endif

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_HepRep
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_HepRep
#endif





#ifdef USE_stub_in_nt_dll
#ifndef USE_core_stub_in_nt_dll
#define USE_core_stub_in_nt_dll
#endif
#ifndef USE_dyn_stub_in_nt_dll
#define USE_dyn_stub_in_nt_dll
#endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_StringArray;

class StringArray_var;

class StringArray : public _CORBA_Unbounded_Sequence_String {
public:
  typedef StringArray_var _var_type;
  inline StringArray() {}
  inline StringArray(const StringArray& _s)
    : _CORBA_Unbounded_Sequence_String(_s) {}

  inline StringArray(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_String(_max) {}
  inline StringArray(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}



  inline StringArray& operator = (const StringArray& _s) {
    _CORBA_Unbounded_Sequence_String::operator=(_s);
    return *this;
  }
};

class StringArray_out;

class StringArray_var {
public:
  inline StringArray_var() : _pd_seq(0) {}
  inline StringArray_var(StringArray* _s) : _pd_seq(_s) {}
  inline StringArray_var(const StringArray_var& _s) {
    if( _s._pd_seq )  _pd_seq = new StringArray(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~StringArray_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline StringArray_var& operator = (StringArray* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline StringArray_var& operator = (const StringArray_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new StringArray;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline StringArray* operator -> () { return _pd_seq; }
#if defined(__GNUG__)
  inline operator StringArray& () const { return *_pd_seq; }
#else
  inline operator const StringArray& () const { return *_pd_seq; }
  inline operator StringArray& () { return *_pd_seq; }
#endif
    
  inline const StringArray& in() const { return *_pd_seq; }
  inline StringArray&       inout()    { return *_pd_seq; }
  inline StringArray*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline StringArray* _retn() { StringArray* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class StringArray_out;
  
private:
  StringArray* _pd_seq;
};

class StringArray_out {
public:
  inline StringArray_out(StringArray*& _s) : _data(_s) { _data = 0; }
  inline StringArray_out(StringArray_var& _s)
    : _data(_s._pd_seq) { _s = (StringArray*) 0; }
  inline StringArray_out(const StringArray_out& _s) : _data(_s._data) {}
  inline StringArray_out& operator = (const StringArray_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline StringArray_out& operator = (StringArray* _s) {
    _data = _s;
    return *this;
  }
  inline operator StringArray*&()  { return _data; }
  inline StringArray*& ptr()       { return _data; }
  inline StringArray* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  StringArray*& _data;

private:
  StringArray_out();
  StringArray_out& operator=(const StringArray_var&);
};

struct HepRepAttDef {
  typedef _CORBA_ConstrType_Variable_Var<HepRepAttDef> _var_type;

  
  CORBA::String_member name;

  CORBA::String_member desc;

  CORBA::String_member category;

  CORBA::String_member extra;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HepRepAttDef::_var_type HepRepAttDef_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HepRepAttDef,HepRepAttDef_var > HepRepAttDef_out;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepAttDef;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepAttDefList;

class HepRepAttDefList_var;

class HepRepAttDefList : public _CORBA_Unbounded_Sequence< HepRepAttDef >  {
public:
  typedef HepRepAttDefList_var _var_type;
  inline HepRepAttDefList() {}
  inline HepRepAttDefList(const HepRepAttDefList& _s)
    : _CORBA_Unbounded_Sequence< HepRepAttDef > (_s) {}

  inline HepRepAttDefList(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< HepRepAttDef > (_max) {}
  inline HepRepAttDefList(_CORBA_ULong _max, _CORBA_ULong _len, HepRepAttDef* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< HepRepAttDef > (_max, _len, _val, _rel) {}



  inline HepRepAttDefList& operator = (const HepRepAttDefList& _s) {
    _CORBA_Unbounded_Sequence< HepRepAttDef > ::operator=(_s);
    return *this;
  }
};

class HepRepAttDefList_out;

class HepRepAttDefList_var {
public:
  inline HepRepAttDefList_var() : _pd_seq(0) {}
  inline HepRepAttDefList_var(HepRepAttDefList* _s) : _pd_seq(_s) {}
  inline HepRepAttDefList_var(const HepRepAttDefList_var& _s) {
    if( _s._pd_seq )  _pd_seq = new HepRepAttDefList(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~HepRepAttDefList_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline HepRepAttDefList_var& operator = (HepRepAttDefList* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline HepRepAttDefList_var& operator = (const HepRepAttDefList_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new HepRepAttDefList;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline HepRepAttDef& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline HepRepAttDefList* operator -> () { return _pd_seq; }
#if defined(__GNUG__)
  inline operator HepRepAttDefList& () const { return *_pd_seq; }
#else
  inline operator const HepRepAttDefList& () const { return *_pd_seq; }
  inline operator HepRepAttDefList& () { return *_pd_seq; }
#endif
    
  inline const HepRepAttDefList& in() const { return *_pd_seq; }
  inline HepRepAttDefList&       inout()    { return *_pd_seq; }
  inline HepRepAttDefList*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline HepRepAttDefList* _retn() { HepRepAttDefList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class HepRepAttDefList_out;
  
private:
  HepRepAttDefList* _pd_seq;
};

class HepRepAttDefList_out {
public:
  inline HepRepAttDefList_out(HepRepAttDefList*& _s) : _data(_s) { _data = 0; }
  inline HepRepAttDefList_out(HepRepAttDefList_var& _s)
    : _data(_s._pd_seq) { _s = (HepRepAttDefList*) 0; }
  inline HepRepAttDefList_out(const HepRepAttDefList_out& _s) : _data(_s._data) {}
  inline HepRepAttDefList_out& operator = (const HepRepAttDefList_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline HepRepAttDefList_out& operator = (HepRepAttDefList* _s) {
    _data = _s;
    return *this;
  }
  inline operator HepRepAttDefList*&()  { return _data; }
  inline HepRepAttDefList*& ptr()       { return _data; }
  inline HepRepAttDefList* operator->() { return _data; }

  inline HepRepAttDef& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  HepRepAttDefList*& _data;

private:
  HepRepAttDefList_out();
  HepRepAttDefList_out& operator=(const HepRepAttDefList_var&);
};

struct HepRepAttValue {
  typedef _CORBA_ConstrType_Variable_Var<HepRepAttValue> _var_type;

  
  CORBA::String_member name;

  CORBA::Any value;

  CORBA::Long showLabel;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HepRepAttValue::_var_type HepRepAttValue_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HepRepAttValue,HepRepAttValue_var > HepRepAttValue_out;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepAttValue;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepAttValueList;

class HepRepAttValueList_var;

class HepRepAttValueList : public _CORBA_Unbounded_Sequence< HepRepAttValue >  {
public:
  typedef HepRepAttValueList_var _var_type;
  inline HepRepAttValueList() {}
  inline HepRepAttValueList(const HepRepAttValueList& _s)
    : _CORBA_Unbounded_Sequence< HepRepAttValue > (_s) {}

  inline HepRepAttValueList(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< HepRepAttValue > (_max) {}
  inline HepRepAttValueList(_CORBA_ULong _max, _CORBA_ULong _len, HepRepAttValue* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< HepRepAttValue > (_max, _len, _val, _rel) {}



  inline HepRepAttValueList& operator = (const HepRepAttValueList& _s) {
    _CORBA_Unbounded_Sequence< HepRepAttValue > ::operator=(_s);
    return *this;
  }
};

class HepRepAttValueList_out;

class HepRepAttValueList_var {
public:
  inline HepRepAttValueList_var() : _pd_seq(0) {}
  inline HepRepAttValueList_var(HepRepAttValueList* _s) : _pd_seq(_s) {}
  inline HepRepAttValueList_var(const HepRepAttValueList_var& _s) {
    if( _s._pd_seq )  _pd_seq = new HepRepAttValueList(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~HepRepAttValueList_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline HepRepAttValueList_var& operator = (HepRepAttValueList* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline HepRepAttValueList_var& operator = (const HepRepAttValueList_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new HepRepAttValueList;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline HepRepAttValue& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline HepRepAttValueList* operator -> () { return _pd_seq; }
#if defined(__GNUG__)
  inline operator HepRepAttValueList& () const { return *_pd_seq; }
#else
  inline operator const HepRepAttValueList& () const { return *_pd_seq; }
  inline operator HepRepAttValueList& () { return *_pd_seq; }
#endif
    
  inline const HepRepAttValueList& in() const { return *_pd_seq; }
  inline HepRepAttValueList&       inout()    { return *_pd_seq; }
  inline HepRepAttValueList*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline HepRepAttValueList* _retn() { HepRepAttValueList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class HepRepAttValueList_out;
  
private:
  HepRepAttValueList* _pd_seq;
};

class HepRepAttValueList_out {
public:
  inline HepRepAttValueList_out(HepRepAttValueList*& _s) : _data(_s) { _data = 0; }
  inline HepRepAttValueList_out(HepRepAttValueList_var& _s)
    : _data(_s._pd_seq) { _s = (HepRepAttValueList*) 0; }
  inline HepRepAttValueList_out(const HepRepAttValueList_out& _s) : _data(_s._data) {}
  inline HepRepAttValueList_out& operator = (const HepRepAttValueList_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline HepRepAttValueList_out& operator = (HepRepAttValueList* _s) {
    _data = _s;
    return *this;
  }
  inline operator HepRepAttValueList*&()  { return _data; }
  inline HepRepAttValueList*& ptr()       { return _data; }
  inline HepRepAttValueList* operator->() { return _data; }

  inline HepRepAttValue& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  HepRepAttValueList*& _data;

private:
  HepRepAttValueList_out();
  HepRepAttValueList_out& operator=(const HepRepAttValueList_var&);
};

struct HepRepPoint {
  typedef _CORBA_ConstrType_Variable_Var<HepRepPoint> _var_type;

  
  CORBA::Double x;

  CORBA::Double y;

  CORBA::Double z;

  HepRepAttValueList attValues;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HepRepPoint::_var_type HepRepPoint_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HepRepPoint,HepRepPoint_var > HepRepPoint_out;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepPoint;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepPointList;

class HepRepPointList_var;

class HepRepPointList : public _CORBA_Unbounded_Sequence< HepRepPoint >  {
public:
  typedef HepRepPointList_var _var_type;
  inline HepRepPointList() {}
  inline HepRepPointList(const HepRepPointList& _s)
    : _CORBA_Unbounded_Sequence< HepRepPoint > (_s) {}

  inline HepRepPointList(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< HepRepPoint > (_max) {}
  inline HepRepPointList(_CORBA_ULong _max, _CORBA_ULong _len, HepRepPoint* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< HepRepPoint > (_max, _len, _val, _rel) {}



  inline HepRepPointList& operator = (const HepRepPointList& _s) {
    _CORBA_Unbounded_Sequence< HepRepPoint > ::operator=(_s);
    return *this;
  }
};

class HepRepPointList_out;

class HepRepPointList_var {
public:
  inline HepRepPointList_var() : _pd_seq(0) {}
  inline HepRepPointList_var(HepRepPointList* _s) : _pd_seq(_s) {}
  inline HepRepPointList_var(const HepRepPointList_var& _s) {
    if( _s._pd_seq )  _pd_seq = new HepRepPointList(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~HepRepPointList_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline HepRepPointList_var& operator = (HepRepPointList* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline HepRepPointList_var& operator = (const HepRepPointList_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new HepRepPointList;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline HepRepPoint& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline HepRepPointList* operator -> () { return _pd_seq; }
#if defined(__GNUG__)
  inline operator HepRepPointList& () const { return *_pd_seq; }
#else
  inline operator const HepRepPointList& () const { return *_pd_seq; }
  inline operator HepRepPointList& () { return *_pd_seq; }
#endif
    
  inline const HepRepPointList& in() const { return *_pd_seq; }
  inline HepRepPointList&       inout()    { return *_pd_seq; }
  inline HepRepPointList*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline HepRepPointList* _retn() { HepRepPointList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class HepRepPointList_out;
  
private:
  HepRepPointList* _pd_seq;
};

class HepRepPointList_out {
public:
  inline HepRepPointList_out(HepRepPointList*& _s) : _data(_s) { _data = 0; }
  inline HepRepPointList_out(HepRepPointList_var& _s)
    : _data(_s._pd_seq) { _s = (HepRepPointList*) 0; }
  inline HepRepPointList_out(const HepRepPointList_out& _s) : _data(_s._data) {}
  inline HepRepPointList_out& operator = (const HepRepPointList_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline HepRepPointList_out& operator = (HepRepPointList* _s) {
    _data = _s;
    return *this;
  }
  inline operator HepRepPointList*&()  { return _data; }
  inline HepRepPointList*& ptr()       { return _data; }
  inline HepRepPointList* operator->() { return _data; }

  inline HepRepPoint& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  HepRepPointList*& _data;

private:
  HepRepPointList_out();
  HepRepPointList_out& operator=(const HepRepPointList_var&);
};

struct HepRepInstance {
  typedef _CORBA_ConstrType_Variable_Var<HepRepInstance> _var_type;

  
  CORBA::String_member typeName;

  typedef _CORBA_Unbounded_Sequence< HepRepInstance >  _instances_seq;
  _instances_seq instances;

  HepRepPointList points;

  HepRepAttValueList attValues;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HepRepInstance::_var_type HepRepInstance_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HepRepInstance,HepRepInstance_var > HepRepInstance_out;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepInstance;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepInstanceList;

class HepRepInstanceList_var;

class HepRepInstanceList : public _CORBA_Unbounded_Sequence< HepRepInstance >  {
public:
  typedef HepRepInstanceList_var _var_type;
  inline HepRepInstanceList() {}
  inline HepRepInstanceList(const HepRepInstanceList& _s)
    : _CORBA_Unbounded_Sequence< HepRepInstance > (_s) {}

  inline HepRepInstanceList(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< HepRepInstance > (_max) {}
  inline HepRepInstanceList(_CORBA_ULong _max, _CORBA_ULong _len, HepRepInstance* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< HepRepInstance > (_max, _len, _val, _rel) {}



  inline HepRepInstanceList& operator = (const HepRepInstanceList& _s) {
    _CORBA_Unbounded_Sequence< HepRepInstance > ::operator=(_s);
    return *this;
  }
};

class HepRepInstanceList_out;

class HepRepInstanceList_var {
public:
  inline HepRepInstanceList_var() : _pd_seq(0) {}
  inline HepRepInstanceList_var(HepRepInstanceList* _s) : _pd_seq(_s) {}
  inline HepRepInstanceList_var(const HepRepInstanceList_var& _s) {
    if( _s._pd_seq )  _pd_seq = new HepRepInstanceList(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~HepRepInstanceList_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline HepRepInstanceList_var& operator = (HepRepInstanceList* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline HepRepInstanceList_var& operator = (const HepRepInstanceList_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new HepRepInstanceList;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline HepRepInstance& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline HepRepInstanceList* operator -> () { return _pd_seq; }
#if defined(__GNUG__)
  inline operator HepRepInstanceList& () const { return *_pd_seq; }
#else
  inline operator const HepRepInstanceList& () const { return *_pd_seq; }
  inline operator HepRepInstanceList& () { return *_pd_seq; }
#endif
    
  inline const HepRepInstanceList& in() const { return *_pd_seq; }
  inline HepRepInstanceList&       inout()    { return *_pd_seq; }
  inline HepRepInstanceList*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline HepRepInstanceList* _retn() { HepRepInstanceList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class HepRepInstanceList_out;
  
private:
  HepRepInstanceList* _pd_seq;
};

class HepRepInstanceList_out {
public:
  inline HepRepInstanceList_out(HepRepInstanceList*& _s) : _data(_s) { _data = 0; }
  inline HepRepInstanceList_out(HepRepInstanceList_var& _s)
    : _data(_s._pd_seq) { _s = (HepRepInstanceList*) 0; }
  inline HepRepInstanceList_out(const HepRepInstanceList_out& _s) : _data(_s._data) {}
  inline HepRepInstanceList_out& operator = (const HepRepInstanceList_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline HepRepInstanceList_out& operator = (HepRepInstanceList* _s) {
    _data = _s;
    return *this;
  }
  inline operator HepRepInstanceList*&()  { return _data; }
  inline HepRepInstanceList*& ptr()       { return _data; }
  inline HepRepInstanceList* operator->() { return _data; }

  inline HepRepInstance& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  HepRepInstanceList*& _data;

private:
  HepRepInstanceList_out();
  HepRepInstanceList_out& operator=(const HepRepInstanceList_var&);
};

struct HepRepTreeID {
  typedef _CORBA_ConstrType_Variable_Var<HepRepTreeID> _var_type;

  
  CORBA::String_member name;

  CORBA::String_member version;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HepRepTreeID::_var_type HepRepTreeID_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HepRepTreeID,HepRepTreeID_var > HepRepTreeID_out;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepTreeID;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepTreeIDList;

class HepRepTreeIDList_var;

class HepRepTreeIDList : public _CORBA_Unbounded_Sequence< HepRepTreeID >  {
public:
  typedef HepRepTreeIDList_var _var_type;
  inline HepRepTreeIDList() {}
  inline HepRepTreeIDList(const HepRepTreeIDList& _s)
    : _CORBA_Unbounded_Sequence< HepRepTreeID > (_s) {}

  inline HepRepTreeIDList(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< HepRepTreeID > (_max) {}
  inline HepRepTreeIDList(_CORBA_ULong _max, _CORBA_ULong _len, HepRepTreeID* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< HepRepTreeID > (_max, _len, _val, _rel) {}



  inline HepRepTreeIDList& operator = (const HepRepTreeIDList& _s) {
    _CORBA_Unbounded_Sequence< HepRepTreeID > ::operator=(_s);
    return *this;
  }
};

class HepRepTreeIDList_out;

class HepRepTreeIDList_var {
public:
  inline HepRepTreeIDList_var() : _pd_seq(0) {}
  inline HepRepTreeIDList_var(HepRepTreeIDList* _s) : _pd_seq(_s) {}
  inline HepRepTreeIDList_var(const HepRepTreeIDList_var& _s) {
    if( _s._pd_seq )  _pd_seq = new HepRepTreeIDList(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~HepRepTreeIDList_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline HepRepTreeIDList_var& operator = (HepRepTreeIDList* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline HepRepTreeIDList_var& operator = (const HepRepTreeIDList_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new HepRepTreeIDList;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline HepRepTreeID& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline HepRepTreeIDList* operator -> () { return _pd_seq; }
#if defined(__GNUG__)
  inline operator HepRepTreeIDList& () const { return *_pd_seq; }
#else
  inline operator const HepRepTreeIDList& () const { return *_pd_seq; }
  inline operator HepRepTreeIDList& () { return *_pd_seq; }
#endif
    
  inline const HepRepTreeIDList& in() const { return *_pd_seq; }
  inline HepRepTreeIDList&       inout()    { return *_pd_seq; }
  inline HepRepTreeIDList*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline HepRepTreeIDList* _retn() { HepRepTreeIDList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class HepRepTreeIDList_out;
  
private:
  HepRepTreeIDList* _pd_seq;
};

class HepRepTreeIDList_out {
public:
  inline HepRepTreeIDList_out(HepRepTreeIDList*& _s) : _data(_s) { _data = 0; }
  inline HepRepTreeIDList_out(HepRepTreeIDList_var& _s)
    : _data(_s._pd_seq) { _s = (HepRepTreeIDList*) 0; }
  inline HepRepTreeIDList_out(const HepRepTreeIDList_out& _s) : _data(_s._data) {}
  inline HepRepTreeIDList_out& operator = (const HepRepTreeIDList_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline HepRepTreeIDList_out& operator = (HepRepTreeIDList* _s) {
    _data = _s;
    return *this;
  }
  inline operator HepRepTreeIDList*&()  { return _data; }
  inline HepRepTreeIDList*& ptr()       { return _data; }
  inline HepRepTreeIDList* operator->() { return _data; }

  inline HepRepTreeID& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  HepRepTreeIDList*& _data;

private:
  HepRepTreeIDList_out();
  HepRepTreeIDList_out& operator=(const HepRepTreeIDList_var&);
};

struct HepRepInstanceTree {
  typedef _CORBA_ConstrType_Variable_Var<HepRepInstanceTree> _var_type;

  
  HepRepTreeID id;

  HepRepTreeID typeTreeID;

  HepRepTreeIDList instanceTreeIDs;

  HepRepInstanceList instances;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HepRepInstanceTree::_var_type HepRepInstanceTree_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HepRepInstanceTree,HepRepInstanceTree_var > HepRepInstanceTree_out;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepInstanceTree;

struct HepRepType {
  typedef _CORBA_ConstrType_Variable_Var<HepRepType> _var_type;

  
  CORBA::String_member name;

  CORBA::String_member desc;

  CORBA::String_member infoURL;

  typedef _CORBA_Unbounded_Sequence< HepRepType >  _types_seq;
  _types_seq types;

  HepRepAttDefList attDefs;

  HepRepAttValueList attValues;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HepRepType::_var_type HepRepType_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HepRepType,HepRepType_var > HepRepType_out;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepType;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepTypeList;

class HepRepTypeList_var;

class HepRepTypeList : public _CORBA_Unbounded_Sequence< HepRepType >  {
public:
  typedef HepRepTypeList_var _var_type;
  inline HepRepTypeList() {}
  inline HepRepTypeList(const HepRepTypeList& _s)
    : _CORBA_Unbounded_Sequence< HepRepType > (_s) {}

  inline HepRepTypeList(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< HepRepType > (_max) {}
  inline HepRepTypeList(_CORBA_ULong _max, _CORBA_ULong _len, HepRepType* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< HepRepType > (_max, _len, _val, _rel) {}



  inline HepRepTypeList& operator = (const HepRepTypeList& _s) {
    _CORBA_Unbounded_Sequence< HepRepType > ::operator=(_s);
    return *this;
  }
};

class HepRepTypeList_out;

class HepRepTypeList_var {
public:
  inline HepRepTypeList_var() : _pd_seq(0) {}
  inline HepRepTypeList_var(HepRepTypeList* _s) : _pd_seq(_s) {}
  inline HepRepTypeList_var(const HepRepTypeList_var& _s) {
    if( _s._pd_seq )  _pd_seq = new HepRepTypeList(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~HepRepTypeList_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline HepRepTypeList_var& operator = (HepRepTypeList* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline HepRepTypeList_var& operator = (const HepRepTypeList_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new HepRepTypeList;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline HepRepType& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline HepRepTypeList* operator -> () { return _pd_seq; }
#if defined(__GNUG__)
  inline operator HepRepTypeList& () const { return *_pd_seq; }
#else
  inline operator const HepRepTypeList& () const { return *_pd_seq; }
  inline operator HepRepTypeList& () { return *_pd_seq; }
#endif
    
  inline const HepRepTypeList& in() const { return *_pd_seq; }
  inline HepRepTypeList&       inout()    { return *_pd_seq; }
  inline HepRepTypeList*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline HepRepTypeList* _retn() { HepRepTypeList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class HepRepTypeList_out;
  
private:
  HepRepTypeList* _pd_seq;
};

class HepRepTypeList_out {
public:
  inline HepRepTypeList_out(HepRepTypeList*& _s) : _data(_s) { _data = 0; }
  inline HepRepTypeList_out(HepRepTypeList_var& _s)
    : _data(_s._pd_seq) { _s = (HepRepTypeList*) 0; }
  inline HepRepTypeList_out(const HepRepTypeList_out& _s) : _data(_s._data) {}
  inline HepRepTypeList_out& operator = (const HepRepTypeList_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline HepRepTypeList_out& operator = (HepRepTypeList* _s) {
    _data = _s;
    return *this;
  }
  inline operator HepRepTypeList*&()  { return _data; }
  inline HepRepTypeList*& ptr()       { return _data; }
  inline HepRepTypeList* operator->() { return _data; }

  inline HepRepType& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  HepRepTypeList*& _data;

private:
  HepRepTypeList_out();
  HepRepTypeList_out& operator=(const HepRepTypeList_var&);
};

struct HepRepTypeTree {
  typedef _CORBA_ConstrType_Variable_Var<HepRepTypeTree> _var_type;

  
  HepRepTreeID id;

  HepRepTypeList types;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HepRepTypeTree::_var_type HepRepTypeTree_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HepRepTypeTree,HepRepTypeTree_var > HepRepTypeTree_out;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepTypeTree;

struct HepRepAction {
  typedef _CORBA_ConstrType_Variable_Var<HepRepAction> _var_type;

  
  CORBA::String_member name;

  CORBA::String_member expression;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HepRepAction::_var_type HepRepAction_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HepRepAction,HepRepAction_var > HepRepAction_out;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepAction;

_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRepActionList;

class HepRepActionList_var;

class HepRepActionList : public _CORBA_Unbounded_Sequence< HepRepAction >  {
public:
  typedef HepRepActionList_var _var_type;
  inline HepRepActionList() {}
  inline HepRepActionList(const HepRepActionList& _s)
    : _CORBA_Unbounded_Sequence< HepRepAction > (_s) {}

  inline HepRepActionList(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< HepRepAction > (_max) {}
  inline HepRepActionList(_CORBA_ULong _max, _CORBA_ULong _len, HepRepAction* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< HepRepAction > (_max, _len, _val, _rel) {}



  inline HepRepActionList& operator = (const HepRepActionList& _s) {
    _CORBA_Unbounded_Sequence< HepRepAction > ::operator=(_s);
    return *this;
  }
};

class HepRepActionList_out;

class HepRepActionList_var {
public:
  inline HepRepActionList_var() : _pd_seq(0) {}
  inline HepRepActionList_var(HepRepActionList* _s) : _pd_seq(_s) {}
  inline HepRepActionList_var(const HepRepActionList_var& _s) {
    if( _s._pd_seq )  _pd_seq = new HepRepActionList(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~HepRepActionList_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline HepRepActionList_var& operator = (HepRepActionList* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline HepRepActionList_var& operator = (const HepRepActionList_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new HepRepActionList;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline HepRepAction& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline HepRepActionList* operator -> () { return _pd_seq; }
#if defined(__GNUG__)
  inline operator HepRepActionList& () const { return *_pd_seq; }
#else
  inline operator const HepRepActionList& () const { return *_pd_seq; }
  inline operator HepRepActionList& () { return *_pd_seq; }
#endif
    
  inline const HepRepActionList& in() const { return *_pd_seq; }
  inline HepRepActionList&       inout()    { return *_pd_seq; }
  inline HepRepActionList*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline HepRepActionList* _retn() { HepRepActionList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class HepRepActionList_out;
  
private:
  HepRepActionList* _pd_seq;
};

class HepRepActionList_out {
public:
  inline HepRepActionList_out(HepRepActionList*& _s) : _data(_s) { _data = 0; }
  inline HepRepActionList_out(HepRepActionList_var& _s)
    : _data(_s._pd_seq) { _s = (HepRepActionList*) 0; }
  inline HepRepActionList_out(const HepRepActionList_out& _s) : _data(_s._data) {}
  inline HepRepActionList_out& operator = (const HepRepActionList_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline HepRepActionList_out& operator = (HepRepActionList* _s) {
    _data = _s;
    return *this;
  }
  inline operator HepRepActionList*&()  { return _data; }
  inline HepRepActionList*& ptr()       { return _data; }
  inline HepRepActionList* operator->() { return _data; }

  inline HepRepAction& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  HepRepActionList*& _data;

private:
  HepRepActionList_out();
  HepRepActionList_out& operator=(const HepRepActionList_var&);
};

#ifndef __HepRep__
#define __HepRep__

class HepRep;
class _objref_HepRep;
class _impl_HepRep;

typedef _objref_HepRep* HepRep_ptr;
typedef HepRep_ptr HepRepRef;

class HepRep_Helper {
public:
  typedef HepRep_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_HepRep, HepRep_Helper> HepRep_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_HepRep,HepRep_Helper > HepRep_out;

#endif

class HepRep {
public:
  // Declarations for this interface type.
  typedef HepRep_ptr _ptr_type;
  typedef HepRep_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_HepRep :
  public virtual CORBA::Object, public virtual omniObjRef
{
public:
  HepRepInstanceTree* getInstanceTreeTop(const char* instanceTreeName, const char* instanceTreeVersion);
  HepRepTypeTree* getTypeTree(const char* typeTreeName, const char* typeTreeVersion);
  HepRepInstanceTree* getInstances(const char* instanceTreeName, const char* instanceTreeVersion, const StringArray& typeNames);
  HepRepInstanceTree* getInstancesAfterAction(const char* instanceTreeName, const char* instanceTreeVersion, const StringArray& typeNames, const HepRepActionList& actions, CORBA::Boolean getPoints, CORBA::Boolean getDrawAtts, CORBA::Boolean getNonDrawAtts, const StringArray& invertAtts);
  StringArray* getLayerOrder();
  char* checkForException();

  inline _objref_HepRep()  { _PR_setobj(0); }  // nil
  _objref_HepRep(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_HepRep();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_HepRep(const _objref_HepRep&);
  _objref_HepRep& operator = (const _objref_HepRep&);
  // not implemented
};

class _pof_HepRep : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_HepRep() : _OMNI_NS(proxyObjectFactory)(HepRep::_PD_repoId) {}
  virtual ~_pof_HepRep();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_HepRep :
  public virtual omniServant
{
public:
  virtual ~_impl_HepRep();

  virtual HepRepInstanceTree* getInstanceTreeTop(const char* instanceTreeName, const char* instanceTreeVersion) = 0;
  virtual HepRepTypeTree* getTypeTree(const char* typeTreeName, const char* typeTreeVersion) = 0;
  virtual HepRepInstanceTree* getInstances(const char* instanceTreeName, const char* instanceTreeVersion, const StringArray& typeNames) = 0;
  virtual HepRepInstanceTree* getInstancesAfterAction(const char* instanceTreeName, const char* instanceTreeVersion, const StringArray& typeNames, const HepRepActionList& actions, CORBA::Boolean getPoints, CORBA::Boolean getDrawAtts, CORBA::Boolean getNonDrawAtts, const StringArray& invertAtts) = 0;
  virtual StringArray* getLayerOrder() = 0;
  virtual char* checkForException() = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};


_CORBA_GLOBAL_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_HepRep;



class POA_HepRep :
  public virtual _impl_HepRep,
  public virtual PortableServer::ServantBase
{
public:
  virtual ~POA_HepRep();

  inline HepRep_ptr _this() {
    return (HepRep_ptr) _do_this(HepRep::_PD_repoId);
  }
};





#undef _core_attr
#undef _dyn_attr

extern void operator <<= (CORBA::Any& _a, const StringArray& _s);
inline void operator <<= (CORBA::Any& _a, StringArray* _sp) {
  _a <<= *_sp;
  delete _sp;
}
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, StringArray*& _sp);
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, const StringArray*& _sp);

extern void operator<<=(CORBA::Any& _a, const HepRepAttDef& _s);
extern void operator<<=(CORBA::Any& _a, HepRepAttDef* _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepAttDef*& _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepAttDef*& _sp);

extern void operator <<= (CORBA::Any& _a, const HepRepAttDefList& _s);
inline void operator <<= (CORBA::Any& _a, HepRepAttDefList* _sp) {
  _a <<= *_sp;
  delete _sp;
}
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, HepRepAttDefList*& _sp);
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, const HepRepAttDefList*& _sp);

extern void operator<<=(CORBA::Any& _a, const HepRepAttValue& _s);
extern void operator<<=(CORBA::Any& _a, HepRepAttValue* _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepAttValue*& _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepAttValue*& _sp);

extern void operator <<= (CORBA::Any& _a, const HepRepAttValueList& _s);
inline void operator <<= (CORBA::Any& _a, HepRepAttValueList* _sp) {
  _a <<= *_sp;
  delete _sp;
}
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, HepRepAttValueList*& _sp);
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, const HepRepAttValueList*& _sp);

extern void operator<<=(CORBA::Any& _a, const HepRepPoint& _s);
extern void operator<<=(CORBA::Any& _a, HepRepPoint* _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepPoint*& _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepPoint*& _sp);

extern void operator <<= (CORBA::Any& _a, const HepRepPointList& _s);
inline void operator <<= (CORBA::Any& _a, HepRepPointList* _sp) {
  _a <<= *_sp;
  delete _sp;
}
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, HepRepPointList*& _sp);
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, const HepRepPointList*& _sp);

extern void operator<<=(CORBA::Any& _a, const HepRepInstance& _s);
extern void operator<<=(CORBA::Any& _a, HepRepInstance* _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepInstance*& _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepInstance*& _sp);

extern void operator <<= (CORBA::Any& _a, const HepRepInstanceList& _s);
inline void operator <<= (CORBA::Any& _a, HepRepInstanceList* _sp) {
  _a <<= *_sp;
  delete _sp;
}
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, HepRepInstanceList*& _sp);
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, const HepRepInstanceList*& _sp);

extern void operator<<=(CORBA::Any& _a, const HepRepTreeID& _s);
extern void operator<<=(CORBA::Any& _a, HepRepTreeID* _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepTreeID*& _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepTreeID*& _sp);

extern void operator <<= (CORBA::Any& _a, const HepRepTreeIDList& _s);
inline void operator <<= (CORBA::Any& _a, HepRepTreeIDList* _sp) {
  _a <<= *_sp;
  delete _sp;
}
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, HepRepTreeIDList*& _sp);
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, const HepRepTreeIDList*& _sp);

extern void operator<<=(CORBA::Any& _a, const HepRepInstanceTree& _s);
extern void operator<<=(CORBA::Any& _a, HepRepInstanceTree* _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepInstanceTree*& _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepInstanceTree*& _sp);

extern void operator<<=(CORBA::Any& _a, const HepRepType& _s);
extern void operator<<=(CORBA::Any& _a, HepRepType* _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepType*& _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepType*& _sp);

extern void operator <<= (CORBA::Any& _a, const HepRepTypeList& _s);
inline void operator <<= (CORBA::Any& _a, HepRepTypeList* _sp) {
  _a <<= *_sp;
  delete _sp;
}
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, HepRepTypeList*& _sp);
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, const HepRepTypeList*& _sp);

extern void operator<<=(CORBA::Any& _a, const HepRepTypeTree& _s);
extern void operator<<=(CORBA::Any& _a, HepRepTypeTree* _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepTypeTree*& _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepTypeTree*& _sp);

extern void operator<<=(CORBA::Any& _a, const HepRepAction& _s);
extern void operator<<=(CORBA::Any& _a, HepRepAction* _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRepAction*& _sp);
extern CORBA::Boolean operator>>=(const CORBA::Any& _a, const HepRepAction*& _sp);

extern void operator <<= (CORBA::Any& _a, const HepRepActionList& _s);
inline void operator <<= (CORBA::Any& _a, HepRepActionList* _sp) {
  _a <<= *_sp;
  delete _sp;
}
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, HepRepActionList*& _sp);
extern _CORBA_Boolean operator >>= (const CORBA::Any& _a, const HepRepActionList*& _sp);

void operator<<=(CORBA::Any& _a, HepRep_ptr _s);
void operator<<=(CORBA::Any& _a, HepRep_ptr* _s);
CORBA::Boolean operator>>=(const CORBA::Any& _a, HepRep_ptr& _s);



inline void
HepRep::_marshalObjRef(::HepRep_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_HepRep
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_HepRep
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_HepRep
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_HepRep
#endif

#endif  // __HepRep_hh__

